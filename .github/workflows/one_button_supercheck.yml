name: One-Button Supercheck (Diag + YAML Corrector + Repo Audit + Drift + Auto-Triage)

on:
  workflow_dispatch:
    inputs:
      api_base:
        description: "API base URL (e.g., https://your-api.onrender.com). Leave blank to skip runtime diagnostics."
        required: false
        default: ""
      queue_key:
        description: "Worker queue key"
        required: false
        default: "queue:runs"
      timeout_sec:
        description: "Max seconds to wait for worker processing"
        required: false
        default: "75"
      poll_sec:
        description: "Poll interval seconds"
        required: false
        default: "3"
      auto_apply:
        description: "Apply safe fixes autonomously (scaffold required, move extras to ATTIC, remove forbidden)"
        required: false
        default: "false"
      auto_commit:
        description: "Commit fixes directly to main (else PR)"
        required: false
        default: "false"

  # Mobile-friendly file trigger
  push:
    branches: [ "main" ]
    paths:
      - ".github/trigger/supercheck/**"

permissions:
  contents: write
  pull-requests: write
  checks: write
  security-events: write

concurrency:
  group: supercheck-${{ github.ref }}
  cancel-in-progress: true

jobs:
  supercheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # -- Tools ---------------------------------------------------------------
      - name: Ensure tools
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq curl zip || true
          python3 -V
          python3 -m pip install --upgrade pip
          pip install ruamel.yaml yamllint

      - name: Log trigger (breadcrumb trail)
        run: |
          mkdir -p self_healing_out
          echo "{\"ts\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"run_id\":\"${GITHUB_RUN_ID}\",\"attempt\":${GITHUB_RUN_ATTEMPT},\"actor\":\"${GITHUB_ACTOR}\",\"trigger\":\"${{ github.event_name }}:${{ github.ref }}\",\"run_url\":\"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\"}" >> self_healing_out/TRIGGER_EVENTS.jsonl

      # -- Stage A: YAML Corrector + Auto-Fix ---------------------------------
      - name: Run YAML Corrector v2 (or legacy)
        shell: bash
        run: |
          set -e
          mkdir -p self_healing_out scripts
          if [ -f scripts/yaml_corrector_v2.py ]; then
            python3 scripts/yaml_corrector_v2.py --apply || echo "YAML Corrector v2 failed" > self_healing_out/YAML_CORRECTOR_REPORT.md
          elif [ -f scripts/yaml_corrector.py ]; then
            python3 scripts/yaml_corrector.py --apply || echo "YAML Corrector legacy failed" > self_healing_out/YAML_CORRECTOR_REPORT.md
          else
            echo "# YAML Corrector missing" > self_healing_out/YAML_CORRECTOR_REPORT.md
          fi
          [ -f self_healing_out/YAML_CORRECTOR_REPORT.json ] || echo '{}' > self_healing_out/YAML_CORRECTOR_REPORT.json

      - name: Auto-fix known issues (YAML-001 et al.)
        shell: bash
        run: |
          set -e
          if [ -f scripts/auto_fix_known_issues.py ]; then
            python3 scripts/auto_fix_known_issues.py || true
          fi
          [ -f self_healing_out/AUTO_FIX_REPORT.md ] || echo "# Auto-Fix Report\n\n(no known issues detected)" > self_healing_out/AUTO_FIX_REPORT.md
          [ -f self_healing_out/AUTO_FIX_REPORT.json ] || echo '{"detected":[],"fixed":[],"skipped":[],"errors":[]}' > self_healing_out/AUTO_FIX_REPORT.json

      - name: Validate workflows (actionlint + yamllint)
        continue-on-error: true
        run: |
          curl -sSL https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash | bash
          ./actionlint -color -shellcheck= || true
          yamllint -f parsable .github/workflows || true

      - name: Upload YAML Corrector + Auto-Fix bundle
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: yaml_corrector_bundle
          path: |
            self_healing_out/YAML_CORRECTOR_REPORT.*
            self_healing_out/AUTO_FIX_REPORT.*
          if-no-files-found: warn

      # -- README: Supercheck badge + Docs link (idempotent) -------------------
      - name: Ensure README badge + docs link (idempotent)
        shell: bash
        run: |
          set -e
          FILE="README.md"
          [ -f "$FILE" ] || { echo "No README.md; skipping"; exit 0; }

          GSRV="${GITHUB_SERVER_URL:-https://github.com}"
          GREPO="${GITHUB_REPOSITORY:-owner/repo}"
          ACTIONS="${GSRV}/${GREPO}/actions/workflows"
          BADGE_MD="[![Supercheck](${ACTIONS}/one_button_supercheck.yml/badge.svg)](${ACTIONS}/one_button_supercheck.yml)"
          DOCS_MD="<sub>Docs: <a href=\"${GSRV}/${GREPO}/blob/main/public/quicktriggers.html\">QuickTriggers</a></sub>"

          OPEN="<!-- autopatch:badges:start -->"
          CLOSE="<!-- autopatch:badges:end -->"

          BLOCK="$OPEN
$BADGE_MD
<br/>
$DOCS_MD
$CLOSE"

          if grep -q "^# " "$FILE"; then :; else
            # Add H1 from repo name if missing
            TITLE="${GREPO##*/}"
            printf '# %s\n\n' "$TITLE" | cat - "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
          fi

          if grep -q "$OPEN" "$FILE"; then
            # replace block
            awk -v open="$OPEN" -v close="$CLOSE" -v block="$BLOCK" '
              BEGIN{inb=0}
              {
                if ($0==open){ inb=1; print block; next }
                if (inb && $0==close){ inb=0; next }
                if (!inb) print
              }' "$FILE" > "$FILE.autopatch.tmp"
            mv "$FILE.autopatch.tmp" "$FILE"
            echo "README: refreshed badge/docs block"
          else
            # insert after H1
            awk -v block="$BLOCK" '
              BEGIN{done=0}
              {
                print
                if (!done && $0 ~ /^# /){ print ""; print block; print ""; done=1 }
              }' "$FILE" > "$FILE.autopatch.tmp"
            mv "$FILE.autopatch.tmp" "$FILE"
            echo "README: inserted badge/docs block"
          fi

      # -- Stage B: Runtime Diagnostics ---------------------------------------
      - name: Runtime diagnostics (API + Worker)
        id: diag
        env:
          API_BASE:   ${{ github.event.inputs.api_base }}
          QUEUE_KEY:  ${{ github.event.inputs.queue_key }}
          TIMEOUT_SEC: ${{ github.event.inputs.timeout_sec }}
          POLL_SEC:   ${{ github.event.inputs.poll_sec }}
        run: |
          set -euo pipefail
          API="${API_BASE}"
          if [ -z "$API" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            printf '{"ok":null,"skipped":true}\n' > supercheck_diag.json
            exit 0
          fi
          sudo apt-get install -y curl jq >/dev/null 2>&1 || true
          API="$(echo "$API" | sed 's:/*$::')"
          get(){ curl -sS -w "\n%{http_code}" "$1"; }
          post(){ curl -sS -w "\n%{http_code}" -X POST "$1" -H "Content-Type: application/json" -d "{}"; }
          pass=true; report='{"api_base":"'"$API"'","steps":[],"ok":false}'
          add(){ if [ -n "${3:-}" ]; then DATA_JSON="$3"; else DATA_JSON="null"; fi; report="$(jq -c --arg n "$1" --argjson ok "${2:-false}" --argjson data "$DATA_JSON" --arg e "${4:-}" '.steps += [{"name":$n,"ok":$ok,"data":$data,"error":( ($e|length)>0 ? $e : null)}]' <<<"$report")"; }
          read -r b s < <(get "$API/v1/ops/health"); if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/health" true  "$(echo "$b"|jq -cS .)"; else add "GET /v1/ops/health" false "" "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/env/required"); if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/env/required" true "$(echo "$b"|jq -cS .)"; else add "GET /v1/ops/env/required" false "" "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/metrics"); if [ "${s:-500}" = "200" ]; then PB="$(echo "$b"|jq -r '.processed // 0')"; add "GET /v1/ops/metrics (before)" true "$(echo "$b"|jq -cS .)"; else PB=0; add "GET /v1/ops/metrics (before)" false "" "HTTP $s"; pass=false; fi
          read -r b s < <(post "$API/v1/ops/queue/test"); if [ "${s:-500}" = "200" ] && [ "$(echo "$b"|jq -r '.queued // false')" = "true" ]; then add "POST /v1/ops/queue/test" true "$(echo "$b"|jq -cS .)"; else add "POST /v1/ops/queue/test" false "" "HTTP $s"; pass=false; fi
          end=$(( $(date +%s) + ${TIMEOUT_SEC} )); snaps="[]"; PA="$PB"
          if [ "$pass" = true ]; then
            while [ $(date +%s) -lt "$end" ]; do
              sleep "${POLL_SEC}"; read -r b s < <(get "$API/v1/ops/metrics")
              if [ "${s:-500}" = "200" ]; then snaps=$(jq -c --argjson s "$(echo "$b"|jq -cS .)" '. + [ $s ]' <<<"$snaps"); val="$(echo "$b"|jq -r '.processed // 0')"; PA="$val"; [ "$PA" -gt "$PB" ] && break; fi
            done
            ok=$([ "$PA" -gt "$PB" ] && echo true || echo false)
            add "Poll metrics until processed increases" "$ok" "$snaps" "before=$PB after=$PA timeout=${TIMEOUT_SEC}s"
            [ "$ok" = true ] || pass=false
          fi
          report="$(jq -c --argjson ok $([ "$pass" = true ] && echo true || echo false) '.ok=$ok' <<<"$report")"
          echo "$report" | jq -S . > supercheck_diag.json
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "ok=$pass" >> $GITHUB_OUTPUT

      # -- Stage C: Repo Audit & Drift ----------------------------------------
      - name: Seed helper scripts if missing
        run: |
          set -e
          mkdir -p scripts self_healing_out
          seed_py(){ f="$1"; shift; [ -f "scripts/$f" ] && return 0; cat > "scripts/$f" <<'PY'
# !/usr/bin/env python3
from pathlib import Path; import time
ROOT=Path(__file__).resolve().parents[1]; OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
(Path(OUT)/f"{__file__.split('/')[-1]}.md").write_text(f"Ran placeholder for {__file__} at {time.time()}\n")
print("OK")
PY
          }
          seed_py repo_audit.py
          seed_py topic_drift_audit.py
          seed_py collect_self_healing.py
          seed_py auto_triage.py

      - name: Repo Inventory & Diff
        run: python3 scripts/repo_audit.py

      - name: Topic Drift Auditor
        run: python3 scripts/topic_drift_audit.py

      # -- Stage D: Self-Healing Scan -----------------------------------------
      - name: Self-Healing Scan (minimal)
        run: python3 scripts/collect_self_healing.py

      # -- Stage E: Auto-Triage -----------------------------------------------
      - name: Auto-Triage (plan + optional apply)
        env:
          APPLY: ${{ github.event.inputs.auto_apply }}
        run: |
          if [ "${APPLY}" = "true" ]; then APPLY=1 python3 scripts/auto_triage.py; else python3 scripts/auto_triage.py; fi

      # -- Stage F: Commit/PR (optional) --------------------------------------
      - name: Commit or PR changes
        if: ${{ github.event.inputs.auto_apply == 'true' || github.event.inputs.auto_commit == 'true' }}
        env:
          DO_COMMIT: ${{ github.event.inputs.auto_commit }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          git config user.name "supercheck-bot"
          git config user.email "bot@stegverse.local"
          CHANGED="0"
          git add -A
          if ! git diff --cached --quiet; then
            CHANGED="1"
            git commit -m "supercheck(auto): repo triage + README badge/docs + workflow normalizations"
          fi

          if [ "$CHANGED" = "1" ]; then
            if [ "$DO_COMMIT" = "true" ]; then
              git push origin HEAD:main || true
            else
              BR="supercheck/triage-${GITHUB_RUN_ID}"
              git checkout -b "$BR" || git checkout "$BR"
              git push origin "$BR" || true
              TITLE="Supercheck: auto changes (triage + README + workflows)"
              BODY="This PR was created by One-Button Supercheck.\n\nIncludes README badge/docs injection, triage output, and safe normalizations.\n\nSee 'supercheck_bundle' artifact."
              curl -sS -X POST \
                -H "Authorization: Bearer ${GH_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -d "$(jq -nc --arg t "$TITLE" --arg b "$BODY" --arg head "$BR" '{"title":$t,"body":$b,"head":$head,"base":"main","maintainer_can_modify":true}')" \
                "${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/pulls" >/dev/null || true
            fi
          else
            echo "No repository changes to commit/PR."
          fi

      # -- Stage G: Assemble Report -------------------------------------------
      - name: Create README meta helper (inline)
        run: |
          cat > scripts/scan_readme_meta.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail
FILE="${1:-README.md}"
[ -f "$FILE" ] || { echo '{"present":false}'; exit 0; }
jq -n \
 --arg h1 "$(awk '/^# /{print substr($0,3); exit}' "$FILE" 2>/dev/null)" \
 --arg badges "$(grep -q '<!-- autopatch:badges:start -->' "$FILE" && echo yes || echo no)" \
 --arg toc "$(grep -q '<!-- autopatch:toc:start -->' "$FILE" && echo yes || echo no)" \
 '{present:true,h1:$h1,badges:($badges=="yes"),toc:($toc=="yes")}'
SH
          chmod +x scripts/scan_readme_meta.sh

      - name: Assemble Supercheck Report
        run: |
          set -e
          echo "# Supercheck Report" > supercheck_report.md
          echo "" >> supercheck_report.md

          echo "## YAML Corrector" >> supercheck_report.md
          cat self_healing_out/YAML_CORRECTOR_REPORT.md >> supercheck_report.md || echo "(no YAML report)" >> supercheck_report.md
          echo "" >> supercheck_report.md

          echo "## Auto-Fix (Known Issues)" >> supercheck_report.md
          cat self_healing_out/AUTO_FIX_REPORT.md >> supercheck_report.md || echo "(no auto-fix activity)" >> supercheck_report.md
          echo "" >> supercheck_report.md

          if [ -f supercheck_diag.json ]; then
            OK=$(jq -r '.ok' supercheck_diag.json 2>/dev/null || echo null)
            if [ "$OK" != "null" ]; then
              BADGE=$([ "$OK" = "true" ] && echo "✅ PASS" || echo "❌ FAIL")
              echo "## API/Worker Diagnostics — $BADGE" >> supercheck_report.md
              echo "" >> supercheck_report.md
              jq -S . supercheck_diag.json | head -c 180000 | sed 's/^/    /' >> supercheck_report.md
              echo "" >> supercheck_report.md
            fi
          fi

          echo "## Repo Inventory & Diff" >> supercheck_report.md
          echo "" >> supercheck_report.md
          cat self_healing_out/REPO_INVENTORY.md >> supercheck_report.md || true
          echo "" >> supercheck_report.md

          echo "## Drift Report" >> supercheck_report.md
          echo "" >> supercheck_report.md
          cat self_healing_out/DRIFT_REPORT.md >> supercheck_report.md || true
          echo "" >> supercheck_report.md

          echo "## Self-Healing Manifest" >> supercheck_report.md
          echo "" >> supercheck_report.md
          cat self_healing_out/SELF_HEALING_MANIFEST.md >> supercheck_report.md || true
          echo "" >> supercheck_report.md

          echo "## Auto-Triage Plan" >> supercheck_report.md
          echo "" >> supercheck_report.md
          cat self_healing_out/AUTO_TRIAGE_REPORT.md >> supercheck_report.md || true
          echo "" >> supercheck_report.md

          echo "## README Meta" >> supercheck_report.md
          bash scripts/scan_readme_meta.sh | jq -S . | sed 's/^/    /' >> supercheck_report.md || true
          echo "" >> supercheck_report.md

      # -- Stage H: Upload artifacts ------------------------------------------
      - name: Upload Sweep (reusable if present; else skip)
        if: always()
        uses: ./.github/workflows/_reusables/upload-sweep.yml
        with:
          name: supercheck_sweep
          base_dir: self_healing_out
          files: |
            SWEEP_REPORT.json
            SWEEP_REPORT.md
            AUTO_TRIAGE_REPORT.md
          extra_globs: |
            REPO_INVENTORY*.md
            DRIFT_REPORT*.md
          create_placeholder: true
          placeholder_msg: "Supercheck did not produce a sweep report this run."

      - name: Upload Supercheck Bundle
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: supercheck_bundle
          path: |
            supercheck_report.md
            supercheck_diag.json
            self_healing_out/**
          if-no-files-found: warn

      - name: Telemetry (reusable if present; else skip)
        if: always()
        uses: ./.github/workflows/_reusables/telemetry.yml
        with:
          basename: supercheck
          status: ${{ job.status }}
