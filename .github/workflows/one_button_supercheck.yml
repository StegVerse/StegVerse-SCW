name: One-Button Supercheck (Diag + Repo Audit + Self-Healing)

on:
  workflow_dispatch:
    inputs:
      api_base:
        description: "Your API base URL (e.g., https://your-api.onrender.com). Leave blank to skip API/worker diagnostics."
        required: false
        default: ""
      queue_key:
        description: "Queue key worker uses (default: queue:runs)"
        required: false
        default: "queue:runs"
      timeout_sec:
        description: "Max seconds to wait for worker to process"
        required: false
        default: "75"
      poll_sec:
        description: "Seconds between polls"
        required: false
        default: "3"

jobs:
  supercheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          python3 -V

      # --- Ensure repo_audit.py exists (drop-in) ---
      - name: Ensure scripts/repo_audit.py
        run: |
          mkdir -p scripts self_healing_out
          if [ ! -f scripts/repo_audit.py ]; then
            cat > scripts/repo_audit.py <<'PY'
#!/usr/bin/env python3
import os, sys, json, hashlib, fnmatch, time
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
DEFAULT_IGNORE = [".git/**","**/__pycache__/**","node_modules/**",".idea/**",".vscode/**",".DS_Store"]
def sha256_file(p, cap=2_000_000):
    h=hashlib.sha256(); n=0
    with open(p,"rb") as f:
        for chunk in iter(lambda: f.read(65536), b""):
            h.update(chunk); n+=len(chunk)
            if n>=cap: break
    return h.hexdigest(), n
def load_spec():
    p=ROOT/"REPO_SPEC.json"
    if p.exists():
        try: return json.loads(p.read_text(encoding="utf-8"))
        except Exception as e: return {"_error": f"bad REPO_SPEC.json: {e}",
            "ignore_globs":DEFAULT_IGNORE,"required_files":[],"required_dirs":[],"recommended_files":[],"forbidden_globs":["**/*.env","**/secrets.*","**/*.pem","**/*.key","**/*.crt","private/**"]}
    return {"ignore_globs":DEFAULT_IGNORE,"required_files":[],"required_dirs":[],"recommended_files":[],"forbidden_globs":["**/*.env","**/secrets.*","**/*.pem","**/*.key","**/*.crt","private/**"]}
def match_any(rel, pats): 
    import fnmatch
    return any(fnmatch.fnmatch(rel, pat) or rel==pat for pat in pats)
def main():
    spec=load_spec()
    ignore=spec.get("ignore_globs") or DEFAULT_IGNORE
    req=spec.get("required_files",[]); rdirs=spec.get("required_dirs",[])
    rec=spec.get("recommended_files",[]); forb=spec.get("forbidden_globs",[])
    files=[]
    for p in ROOT.rglob("*"):
        if p.is_file():
            rel=p.relative_to(ROOT).as_posix()
            if any(fnmatch.fnmatch(rel, pat) for pat in ignore): continue
            files.append(rel)
    files=sorted(files)
    inv=[]
    for rel in files:
        p=ROOT/rel; size=p.stat().st_size
        try: d,n=sha256_file(p)
        except Exception as e: d,f"error:{e}"; n=0
        inv.append({"path":rel,"size":size,"sha256":d,"sampled_bytes":n})
    present=set(files)
    missing=[f for f in req if f not in present]
    dir_missing=[d for d in rdirs if not (ROOT/d).exists()]
    rec_missing=[f for f in rec if f not in present]
    forb_hits=[rel for rel in files if match_any(rel, forb)]
    wanted=set(req)|set(rec)
    extras=[rel for rel in files if rel not in wanted]
    ts=int(time.time())
    (OUT/"REPO_INVENTORY.json").write_text(json.dumps({
        "repo": os.getenv("GITHUB_REPOSITORY", ROOT.name),
        "generated_at": ts,"counts":{"files":len(files)},
        "inventory": inv
    },indent=2), encoding="utf-8")
    (OUT/"REPO_DIFF.json").write_text(json.dumps({
        "summary":{"required_missing":len(missing),"dir_missing":len(dir_missing),
                   "recommended_missing":len(rec_missing),"forbidden_hits":len(forb_hits),"extras":len(extras)},
        "required_missing":missing,"dir_missing":dir_missing,
        "recommended_missing":rec_missing,"forbidden_hits":forb_hits,"extras":extras
    },indent=2), encoding="utf-8")
    md=[]
    md.append(f"# Repo Inventory & Diff — {os.getenv('GITHUB_REPOSITORY', ROOT.name)}\n")
    md.append(f"- Files scanned: **{len(files)}**\n")
    def sec(title, items):
        md.append(f"## {title} ({len(items)})")
        if not items: md.append("- ✅ None\n"); return
        for it in items: md.append(f"- `{it}`")
        md.append("")
    sec("Required files missing", missing)
    sec("Required directories missing", dir_missing)
    sec("Recommended files missing", rec_missing)
    sec("Forbidden items present", forb_hits)
    sec("Extras (not required/recommended)", extras[:200])
    (OUT/"REPO_INVENTORY.md").write_text("\n".join(md), encoding="utf-8")
    print("OK repo_audit")
if __name__=="__main__": main()
PY
            chmod +x scripts/repo_audit.py
          fi

      # --- Ensure a minimal collect_self_healing.py exists (for scan) ---
      - name: Ensure scripts/collect_self_healing.py (minimal)
        run: |
          if [ ! -f scripts/collect_self_healing.py ]; then
            cat > scripts/collect_self_healing.py <<'PY'
#!/usr/bin/env python3
import os, json, datetime
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
def ls(pats):
  out=[]; 
  for pat in pats:
    out += [str(p) for p in ROOT.glob(pat) if p.is_file()]
  return sorted(out)
manifest={"repo":os.getenv("GITHUB_REPOSITORY",ROOT.name),
"branch":os.getenv("GITHUB_REF_NAME",""),
"generated_at":datetime.datetime.utcnow().isoformat()+"Z",
"measures":{"workflows":ls([".github/workflows/*.yml",".github/workflows/*.yaml"]),
"scripts":ls(["scripts/*.sh","scripts/*.py"]),
"config":ls(["render.yaml","api/requirements.txt","package.json","pnpm-lock.yaml","yarn.lock","package-lock.json"]),
"ui":ls(["public/diag.html"]),
"api":ls(["api/main.py","api/app/main.py"])}}
(OUT/"SELF_HEALING_MANIFEST.json").write_text(json.dumps(manifest,indent=2),encoding="utf-8")
(OUT/"SELF_HEALING_MANIFEST.md").write_text("# Minimal Manifest\n\n```\n"+json.dumps(manifest,indent=2)+"\n```",encoding="utf-8")
(OUT/"GAPS.json").write_text(json.dumps({"note":"minimal scan"},indent=2),encoding="utf-8")
(OUT/"REMEDIATIONS.md").write_text("",encoding="utf-8")
print("OK scan")
PY
            chmod +x scripts/collect_self_healing.py
          fi

      # --- (A) API + Worker diagnostics (only if api_base provided) ---
      - name: Run API/Worker diagnostics (optional)
        id: diag
        env:
          API_BASE: ${{ github.event.inputs.api_base }}
          QUEUE_KEY: ${{ github.event.inputs.queue_key }}
          TIMEOUT_SEC: ${{ github.event.inputs.timeout_sec }}
          POLL_SEC: ${{ github.event.inputs.poll_sec }}
        run: |
          set -euo pipefail
          API="${API_BASE}"
          if [ -z "$API" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            printf '{"ok":null,"skipped":true}\n' > supercheck_diag.json
            exit 0
          fi
          API="$(echo "$API" | sed 's:/*$::')"
          TIMEOUT="${TIMEOUT_SEC}"; POLL="${POLL_SEC}"
          get()  { curl -sS -w "\n%{http_code}" "$1"; }
          post() { curl -sS -w "\n%{http_code}" -X POST "$1" -H "Content-Type: application/json" -d "{}"; }
          pass=true
          report='{"api_base":"'"$API"'","steps":[],"ok":false}'
          add_step(){ report=$(jq -c --arg n "$1" --argjson ok $2 --argjson data "$3" --arg err "${4:-}" '.steps += [{"name":$n,"ok":$ok,"data":$data,"error":(($err|length>0)?$err:null)}]' <<<"$report"); }
          # health
          read -r b s < <(get "$API/v1/ops/health")
          if [ "${s:-500}" = "200" ]; then add_step "GET /v1/ops/health" true "$(echo "$b" | jq -S .)" ""; else add_step "GET /v1/ops/health" false null "HTTP $s"; pass=false; fi
          # env required
          read -r b s < <(get "$API/v1/ops/env/required")
          if [ "${s:-500}" = "200" ]; then add_step "GET /v1/ops/env/required" true "$(echo "$b" | jq -S .)" ""; else add_step "GET /v1/ops/env/required" false null "HTTP $s"; pass=false; fi
          # metrics before
          read -r b s < <(get "$API/v1/ops/metrics")
          if [ "${s:-500}" = "200" ]; then PB=$(echo "$b"|jq -r '.processed // 0'); add_step "GET /v1/ops/metrics (before)" true "$(echo "$b"|jq -S .)" ""; else add_step "GET /v1/ops/metrics (before)" false null "HTTP $s"; pass=false; fi
          # enqueue
          read -r b s < <(post "$API/v1/ops/queue/test")
          if [ "${s:-500}" = "200" ] && [ "$(echo "$b"|jq -r '.queued // false')" = "true" ]; then add_step "POST /v1/ops/queue/test" true "$(echo "$b"|jq -S .)" ""; else add_step "POST /v1/ops/queue/test" false null "HTTP $s"; pass=false; fi
          # poll
          snaps="[]"; PA="$PB"
          if [ "$pass" = true ]; then
            end=$(( $(date +%s) + ${TIMEOUT} ))
            while [ $(date +%s) -lt $end ]; do
              sleep "$POLL"; read -r b s < <(get "$API/v1/ops/metrics")
              if [ "${s:-500}" = "200" ]; then snaps=$(jq -c --argjson s "$(echo "$b"|jq -S .)" '.+=[ $s ]' <<<"$snaps"); val=$(echo "$b"|jq -r '.processed // 0'); PA=$val; [ "$PA" -gt "$PB" ] && break; fi
            done
            ok=$([ "$PA" -gt "$PB" ] && echo true || echo false)
            add_step "Poll metrics until processed increases" "$ok" "$snaps" "before=$PB after=$PA timeout=${TIMEOUT}s"
            [ "$ok" = true ] || pass=false
          fi
          report=$(jq -c --argjson ok $([ "$pass" = true ] && echo true || echo false) '.ok=$ok' <<<"$report")
          echo "$report" | jq -S . > supercheck_diag.json
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "ok=$pass" >> $GITHUB_OUTPUT

      # --- (B) Repo audit ---
      - name: Run Repo Inventory & Diff
        run: |
          python3 scripts/repo_audit.py
          cp self_healing_out/REPO_INVENTORY.md supercheck_repo.md || true

      # --- (C) Self-Healing Scan (minimal) ---
      - name: Run Self-Healing Scan (minimal)
        run: |
          python3 scripts/collect_self_healing.py
          cp self_healing_out/SELF_HEALING_MANIFEST.md supercheck_scan.md || true

      # --- Build a single human-readable report ---
      - name: Assemble Supercheck Report
        run: |
          set -e
          echo "# Supercheck Report" > supercheck_report.md
          echo "" >> supercheck_report.md
          if [ -f supercheck_diag.json ]; then
            OK=$(jq -r '.ok' supercheck_diag.json 2>/dev/null || echo null)
            if [ "$OK" != "null" ]; then
              BADGE=$([ "$OK" = "true" ] && echo "✅ PASS" || echo "❌ FAIL")
              echo "## API/Worker Diagnostics — $BADGE" >> supercheck_report.md
              echo "" >> supercheck_report.md
              echo "<details><summary>diagnostic JSON</summary>" >> supercheck_report.md
              echo "" >> supercheck_report.md
              jq -S . supercheck_diag.json | head -c 200000 | sed 's/^/    /' >> supercheck_report.md
              echo "" >> supercheck_report.md
              echo "</details>" >> supercheck_report.md
              echo "" >> supercheck_report.md
            else
              echo "## API/Worker Diagnostics — Skipped" >> supercheck_report.md
              echo "" >> supercheck_report.md
            fi
          fi
          if [ -f supercheck_repo.md ]; then
            echo "## Repo Inventory & Diff" >> supercheck_report.md
            echo "" >> supercheck_report.md
            cat supercheck_repo.md >> supercheck_report.md
            echo "" >> supercheck_report.md
          fi
          if [ -f supercheck_scan.md ]; then
            echo "## Self-Healing Scan Manifest" >> supercheck_report.md
            echo "" >> supercheck_report.md
            cat supercheck_scan.md >> supercheck_report.md
            echo "" >> supercheck_report.md
          fi
          echo "OK" > supercheck_ok.txt

      - name: Upload Supercheck Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: supercheck_bundle
          path: |
            supercheck_report.md
            supercheck_diag.json
            self_healing_out/REPO_INVENTORY.json
            self_healing_out/REPO_INVENTORY.md
            self_healing_out/REPO_DIFF.json
            self_healing_out/SELF_HEALING_MANIFEST.json
            self_healing_out/SELF_HEALING_MANIFEST.md
            self_healing_out/GAPS.json
            self_healing_out/REMEDIATIONS.md
          if-no-files-found: warn
