name: One-Button Supercheck (Diag + YAML Corrector + Repo Audit + Drift + Auto-Triage)

on:
  workflow_dispatch:
    inputs:
      api_base:
        description: "API base URL (https://your-api.onrender.com). Leave blank to skip runtime diagnostics."
        required: false
        default: ""
      queue_key:
        description: "Worker queue key (informational)"
        required: false
        default: "queue:runs"
      timeout_sec:
        description: "Max seconds to wait for worker processing"
        required: false
        default: "75"
      poll_sec:
        description: "Poll interval seconds"
        required: false
        default: "3"
      auto_apply:
        description: "Apply safe triage (scaffold/move ATTIC/remove forbidden)"
        required: false
        default: "false"
      auto_commit:
        description: "Commit direct to main (else open PR)"
        required: false
        default: "false"

  push:
    branches: [ "main" ]
    paths:
      - ".github/trigger/supercheck/**"

permissions:
  contents: write
  pull-requests: write
  checks: write
  security-events: write

concurrency:
  group: supercheck-${{ github.ref }}
  cancel-in-progress: true

jobs:
  setup:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Install base tools
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq curl zip
          python3 -V

  log_trigger:
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Log trigger (breadcrumb)
        run: |
          mkdir -p self_healing_out
          echo "{\"ts\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"run_id\":\"${GITHUB_RUN_ID}\",\"attempt\":${GITHUB_RUN_ATTEMPT},\"actor\":\"${GITHUB_ACTOR}\",\"trigger\":\"${{ github.event_name }}:${{ github.ref }}\",\"run_url\":\"${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}\"}" >> self_healing_out/TRIGGER_EVENTS.jsonl
      - name: Upload trigger log
        uses: actions/upload-artifact@v4
        with:
          name: trigger_log
          path: self_healing_out/TRIGGER_EVENTS.jsonl
          if-no-files-found: warn

  yamlfix:
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Install YAML tools
        run: |
          python3 -m pip install --upgrade pip
          pip install ruamel.yaml yamllint
          curl -sSL https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash | bash
      - name: Run YAML Corrector v2
        run: |
          mkdir -p self_healing_out
          if [ -f scripts/yaml_corrector_v2.py ]; then
            python3 scripts/yaml_corrector_v2.py --apply || true
          else
            echo "# YAML Corrector: script missing (scripts/yaml_corrector_v2.py)" > self_healing_out/YAML_CORRECTOR_REPORT.md
            echo "{}" > self_healing_out/YAML_CORRECTOR_REPORT.json
          fi
      - name: Validate workflows (actionlint + yamllint)
        continue-on-error: true
        run: |
          ./actionlint -color -shellcheck= || true
          yamllint -f parsable .github/workflows || true
      - name: Upload YAML bundle
        uses: actions/upload-artifact@v4
        with:
          name: yaml_corrector_bundle
          path: |
            self_healing_out/YAML_CORRECTOR_REPORT.*
          if-no-files-found: warn

  diag:
    needs: [setup]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Runtime diagnostics (API + Worker)
        id: run
        env:
          API_BASE:   ${{ github.event.inputs.api_base }}
          QUEUE_KEY:  ${{ github.event.inputs.queue_key }}
          TIMEOUT_SEC: ${{ github.event.inputs.timeout_sec }}
          POLL_SEC:   ${{ github.event.inputs.poll_sec }}
        run: |
          set -euo pipefail
          API="${API_BASE}"
          mkdir -p self_healing_out
          if [ -z "$API" ]; then
            printf '{"ok":null,"skipped":true}\n' > self_healing_out/supercheck_diag.json
            exit 0
          fi
          sudo apt-get install -y curl jq >/dev/null 2>&1 || true
          API="$(echo "$API" | sed 's:/*$::')"
          get(){ curl -sS -w "\n%{http_code}" "$1"; }
          post(){ curl -sS -w "\n%{http_code}" -X POST "$1" -H "Content-Type: application/json" -d "{}"; }
          pass=true; report='{"api_base":"'"$API"'","steps":[],"ok":false}'
          add(){ report=$(jq -c --arg n "$1" --argjson ok $2 --argjson data "$3" --arg e "${4:-}" '.steps += [{"name":$n,"ok":$ok,"data":$data,"error":(($e|length>0)?$e:null)}]' <<<"$report"); }
          read -r b s < <(get "$API/v1/ops/health"); if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/health" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/health" false null "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/env/required"); if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/env/required" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/env/required" false null "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/metrics"); if [ "${s:-500}" = "200" ]; then PB=$(echo "$b"|jq -r '.processed // 0'); add "GET /v1/ops/metrics (before)" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/metrics (before)" false null "HTTP $s"; PB=0; pass=false; fi
          read -r b s < <(post "$API/v1/ops/queue/test"); if [ "${s:-500}" = "200" ] && [ "$(echo "$b"|jq -r '.queued // false')" = "true" ]; then add "POST /v1/ops/queue/test" true "$(echo "$b"|jq -S .)" ""; else add "POST /v1/ops/queue/test" false null "HTTP $s"; pass=false; fi
          end=$(( $(date +%s) + ${TIMEOUT_SEC} )); snaps="[]"; PA="$PB"
          if [ "$pass" = true ]; then
            while [ $(date +%s) -lt $end ]; do
              sleep "${POLL_SEC}"; read -r b s < <(get "$API/v1/ops/metrics")
              if [ "${s:-500}" = "200" ]; then snaps=$(jq -c --argjson s "$(echo "$b"|jq -S .)" '.+=[ $s ]' <<<"$snaps"); val=$(echo "$b"|jq -r '.processed // 0'); PA=$val; [ "$PA" -gt "$PB" ] && break; fi
            done
            ok=$([ "$PA" -gt "$PB" ] && echo true || echo false)
            add "Poll metrics until processed increases" "$ok" "$snaps" "before=$PB after=$PA timeout=${TIMEOUT_SEC}s"
            [ "$ok" = true ] || pass=false
          fi
          report=$(jq -c --argjson ok $([ "$pass" = true ] && echo true || echo false) '.ok=$ok' <<<"$report")
          echo "$report" | jq -S . > self_healing_out/supercheck_diag.json
      - name: Upload diag artifact
        uses: actions/upload-artifact@v4
        with:
          name: runtime_diag
          path: self_healing_out/supercheck_diag.json
          if-no-files-found: warn

  audit:
    needs: [setup, yamlfix]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Seed helper scripts if missing
        run: |
          set -e
          mkdir -p scripts self_healing_out
          seed_py(){ f="$1"; shift; [ -f "scripts/$f" ] && return 0; cat > "scripts/$f" <<'PY'
# !/usr/bin/env python3
from pathlib import Path; import time
ROOT=Path(__file__).resolve().parents[1]; OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
(Path(OUT)/f"__placeholder_{__file__.split('/')[-1]}.md").write_text(f"Ran placeholder at {time.time()}\n")
print("OK")
PY
          }
          seed_py repo_audit.py
          seed_py topic_drift_audit.py
          seed_py collect_self_healing.py
      - name: Repo Inventory & Diff
        run: python3 scripts/repo_audit.py
      - name: Topic Drift Auditor
        run: python3 scripts/topic_drift_audit.py
      - name: Self-Healing Scan (manifest)
        run: python3 scripts/collect_self_healing.py
      - name: Upload repo audit bundle
        uses: actions/upload-artifact@v4
        with:
          name: repo_audit_bundle
          path: |
            self_healing_out/REPO_INVENTORY.*
            self_healing_out/REPO_DIFF.json
            self_healing_out/DRIFT_REPORT.*
            self_healing_out/SELF_HEALING_MANIFEST.*
          if-no-files-found: warn

  triage:
    needs: [audit]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Install deps (PyYAML)
        run: |
          python3 -m pip install --upgrade pip
          pip install pyyaml
      - name: Ensure intent & triage rules
        run: |
          set -e
          mkdir -p .steg scripts self_healing_out
          if [ ! -f .steg/INTENT.yml ]; then
            cat > .steg/INTENT.yml <<'YML'
version: 1
required:
  dirs: ["scripts", ".github/workflows", "self_healing_out"]
  files: []
forbidden_globs:
  - "**/*.env"
  - "**/secrets.*"
  - "**/*.pem"
  - "**/*.key"
  - "**/*.crt"
  - "private/**"
attic_policy:
  enable: true
  header:
    why: "Parked by auto-triage per INTENT"
    how_to_restore: "Move out of ATTIC/ and re-link imports if needed"
  exclude:
    - "docs/**"
    - "tests/**"
    - "ATTIC/**"
YML
          fi
          if [ ! -f scripts/triage_rules.json ]; then
            cat > scripts/triage_rules.json <<'JSON'
{
  "version": 1,
  "attic": { "move_if_globs": ["experiments/**","tmp/**","scratch/**"], "exclude_globs": ["docs/**","tests/**","ATTIC/**"] },
  "remove_forbidden": ["**/*.env","**/secrets.*","**/*.pem","**/*.key","**/*.crt","private/**"],
  "scaffold": { "dirs": ["scripts",".github/workflows","self_healing_out"], "files": [] }
}
JSON
          fi
          if [ ! -f scripts/auto_triage.py ]; then
            echo "::warning ::scripts/auto_triage.py not found; seeding no-op placeholder."
            cat > scripts/auto_triage.py <<'PY'
#!/usr/bin/env python3
import os, json
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
plan = {"remove_forbidden": [], "move_to_attic": [], "scaffold_dirs": [], "scaffold_files": [], "keep": []}
(OUT/"AUTO_TRIAGE_PLAN.json").write_text(json.dumps(plan, indent=2), encoding="utf-8")
(OUT/"AUTO_TRIAGE_REPORT.md").write_text("# Auto-Triage Plan\n\n(no-op placeholder)\n", encoding="utf-8")
print("OK")
PY
            chmod +x scripts/auto_triage.py
          fi
      - name: Run auto_triage (apply optional)
        env:
          APPLY: ${{ github.event.inputs.auto_apply }}
        run: |
          if [ "${APPLY}" = "true" ]; then APPLY=1 python3 scripts/auto_triage.py; else python3 scripts/auto_triage.py; fi
      - name: Upload auto-triage bundle
        uses: actions/upload-artifact@v4
        with:
          name: auto_triage_bundle
          path: |
            self_healing_out/AUTO_TRIAGE_PLAN.json
            self_healing_out/AUTO_TRIAGE_REPORT.md
          if-no-files-found: warn

  commit_or_pr:
    needs: [triage]
    if: ${{ github.event.inputs.auto_apply == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Commit to main or open PR
        env:
          DO_COMMIT: ${{ github.event.inputs.auto_commit }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          git config user.name "supercheck-bot"
          git config user.email "bot@stegverse.local"
          if [ "$DO_COMMIT" = "true" ]; then
            git add -A
            git commit -m "supercheck(auto): apply safe triage (scaffold/move ATTIC/remove forbidden)" || echo "No changes"
            git push origin HEAD:main || true
          else
            BR="supercheck/triage-${GITHUB_RUN_ID}"
            git checkout -b "$BR"
            git add -A
            git commit -m "supercheck(auto): apply safe triage (scaffold/move ATTIC/remove forbidden)" || echo "No changes"
            git push origin "$BR" || true
            TITLE="Supercheck: safe triage (auto)"
            BODY="This PR was created by One-Button Supercheck.

- Scaffolds missing files/dirs
- Moves extras to ATTIC with @attic headers
- Removes forbidden files

Review the 'supercheck_bundle' artifact for details."
            curl -sS -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -nc --arg t "$TITLE" --arg b "$BODY" --arg head "$BR" '{"title":$t,"body":$b,"head":$head,"base":"main","maintainer_can_modify":true}')" \
              "${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/pulls" >/dev/null || true

  assemble:
    needs: [yamlfix, diag, audit, triage]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: |
            yaml_corrector_bundle
            runtime_diag
            repo_audit_bundle
            auto_triage_bundle
          path: _in
          merge-multiple: true
      - name: Build report (markdown)
        run: |
          set -e
          mkdir -p out self_healing_out
          RPT="out/supercheck_report.md"
          echo "# Supercheck Report" > "$RPT"
          echo "" >> "$RPT"
          echo "## YAML Corrector" >> "$RPT"
          cat _in/YAML_CORRECTOR_REPORT.md 2>/dev/null || echo "(no YAML report)" >> "$RPT"
          echo "" >> "$RPT"
          if [ -f "_in/supercheck_diag.json" ]; then
            OK="$(jq -r '.ok' _in/supercheck_diag.json 2>/dev/null || echo null)"
            BADGE="(skipped)"; [ "$OK" = "true" ] && BADGE="✅ PASS"; [ "$OK" = "false" ] && BADGE="❌ FAIL"
            echo "## API/Worker Diagnostics — $BADGE" >> "$RPT"
            echo "" >> "$RPT"
            jq -S . _in/supercheck_diag.json | head -c 180000 | sed 's/^/    /' >> "$RPT"
            echo "" >> "$RPT"
          fi
          echo "## Repo Inventory & Diff" >> "$RPT"
          cat _in/REPO_INVENTORY.md 2>/dev/null || echo "(no inventory)" >> "$RPT"
          echo "" >> "$RPT"
          echo "## Drift Report" >> "$RPT"
          cat _in/DRIFT_REPORT.md 2>/dev/null || echo "(no drift report)" >> "$RPT"
          echo "" >> "$RPT"
          echo "## Self-Healing Manifest" >> "$RPT"
          cat _in/SELF_HEALING_MANIFEST.md 2>/dev/null || echo "(no manifest)" >> "$RPT"
          echo "" >> "$RPT"
          echo "## Auto-Triage Plan" >> "$RPT"
          cat _in/AUTO_TRIAGE_REPORT.md 2>/dev/null || echo "(no auto-triage report)" >> "$RPT"
          echo "" >> "$RPT"
      - name: Upload consolidated bundle
        uses: actions/upload-artifact@v4
        with:
          name: supercheck_bundle
          path: |
            out/supercheck_report.md
            _in/**
          if-no-files-found: warn

  telemetry:
    needs: [assemble]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          fetch-depth: 1
      - name: Record outcome (last-two)
        if: always()
        run: |
          set -e
          mkdir -p self_healing_out
          TS="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          SHA="$(git rev-parse --short HEAD || echo unknown)"
          RUN_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          LEDGER="self_healing_out/TRIGGER_EVENTS_Supercheck.jsonl"
          echo "{\"ts\":\"$TS\",\"status\":\"${{ needs.assemble.result }}\",\"sha\":\"$SHA\",\"run_url\":\"$RUN_URL\",\"actor\":\"${GITHUB_ACTOR}\"}" >> "$LEDGER"
          tail -n 2 "$LEDGER" | jq -s '.' > self_healing_out/LAST_TWO_supercheck.json || echo "[]" > self_healing_out/LAST_TWO_supercheck.json
          {
            echo "### Last two Supercheck outcomes"
            jq -r '.[] | "- **\(.status | ascii_upcase)** — \(.ts) — `\(.sha)`  [(run)](\(.run_url)) by \(.actor)"' self_healing_out/LAST_TWO_supercheck.json 2>/dev/null || true
          } > self_healing_out/LAST_TWO_supercheck.md
      - name: Upload last-two summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: last_two_supercheck
          path: |
            self_healing_out/LAST_TWO_supercheck.json
            self_healing_out/LAST_TWO_supercheck.md
          if-no-files-found: warn
