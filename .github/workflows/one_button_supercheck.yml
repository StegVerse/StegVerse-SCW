name: One-Button Supercheck (Diag + Repo Audit + Drift + Auto-Triage) [Hardened]

on:
  workflow_dispatch:
    inputs:
      api_base:
        description: "API base URL; blank = skip diagnostics"
        required: false
        default: ""
      queue_key:
        description: "Worker queue key"
        required: false
        default: "queue:runs"
      timeout_sec:
        description: "Max seconds to wait for worker"
        required: false
        default: "75"
      poll_sec:
        description: "Poll interval seconds"
        required: false
        default: "3"
      auto_apply:
        description: "Apply safe fixes (ATTIC/scaffold/remove forbidden)"
        required: false
        default: "false"
      auto_commit:
        description: "Commit fixes directly to main (else PR)"
        required: false
        default: "false"

permissions:
  contents: write
  pull-requests: write

jobs:
  supercheck:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq curl
          python3 -V

      # --- Seed minimal fallbacks so missing scripts never break the run ---
      - name: Seed fallback scripts if missing
        run: |
          set -e
          mkdir -p scripts self_healing_out .github/workflows ATTIC docs

          # validate_and_fix.py fallback (writes a minimal report)
          if [ ! -f scripts/validate_and_fix.py ]; then
            cat > scripts/validate_and_fix.py <<'PY'
#\!/usr/bin/env python3
import os, json, sys
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
WF=ROOT/".github"/"workflows"
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
files=sorted([p.as_posix() for p in WF.glob("*.y*ml")]) if WF.exists() else []
summary={"files":len(files),"changed":0,"invalid_before":0,"invalid_after":0,"applied":"--apply" in sys.argv,"note":"fallback validator (real script not found)"}
(OUT/"WORKFLOW_FIX_REPORT.json").write_text(json.dumps({"summary":summary,"results":[{"path":f,"changed":False,"before_valid":True,"after_valid":True,"text_stats":{},"yaml_stats":{}} for f in files]},indent=2),encoding="utf-8")
(OUT/"WORKFLOW_FIX_REPORT.md").write_text("# Workflow Fix Report\n\n- Fallback stub executed (real validator missing)\n- Files found: **{}**\n".format(len(files)),encoding="utf-8")
print(json.dumps(summary, indent=2))
PY
            chmod +x scripts/validate_and_fix.py
          fi

          # repo_audit.py fallback (creates inventory placeholders)
          if [ ! -f scripts/repo_audit.py ]; then
            cat > scripts/repo_audit.py <<'PY'
#\!/usr/bin/env python3
import os, json
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
(OUT/"REPO_INVENTORY.json").write_text(json.dumps({"repo":ROOT.name,"inventory":[],"counts":{"files":0}},indent=2),encoding="utf-8")
(OUT/"REPO_DIFF.json").write_text(json.dumps({"summary":{"required_missing":0,"dir_missing":0,"recommended_missing":0,"forbidden_hits":0,"extras":0},"required_missing":[],"dir_missing":[],"recommended_missing":[],"forbidden_hits":[],"extras":[]},indent=2),encoding="utf-8")
(OUT/"REPO_INVENTORY.md").write_text("# Repo Inventory & Diff\n\n- (fallback stub)\n",encoding="utf-8")
print("OK repo_audit (fallback)")
PY
            chmod +x scripts/repo_audit.py
          fi

          # topic_drift_audit.py fallback
          if [ ! -f scripts/topic_drift_audit.py ]; then
            cat > scripts/topic_drift_audit.py <<'PY'
#\!/usr/bin/env python3
import json, time
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
rep={"generated_at":int(time.time()),"files_scanned":0,"idea_tags":{},"attic_files":[],"possibly_unused":[],"commit_topics_last200":[],"drift_ratio_no_topic":None}
(OUT/"DRIFT_REPORT.json").write_text(json.dumps(rep,indent=2),encoding="utf-8")
(OUT/"DRIFT_REPORT.md").write_text("# Drift Report\n\n- (fallback stub)\n",encoding="utf-8")
print("OK drift_report (fallback)")
PY
            chmod +x scripts/topic_drift_audit.py
          fi

          # collect_self_healing.py fallback
          if [ ! -f scripts/collect_self_healing.py ]; then
            cat > scripts/collect_self_healing.py <<'PY'
#\!/usr/bin/env python3
import os, json, datetime
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
manifest={"repo":os.getenv("GITHUB_REPOSITORY",ROOT.name),"branch":os.getenv("GITHUB_REF_NAME",""),"generated_at":datetime.datetime.utcnow().isoformat()+"Z","measures":{}}
(OUT/"SELF_HEALING_MANIFEST.json").write_text(json.dumps(manifest,indent=2),encoding="utf-8")
(OUT/"SELF_HEALING_MANIFEST.md").write_text("# Minimal Manifest (fallback)\n",encoding="utf-8")
(OUT/"GAPS.json").write_text(json.dumps({"note":"fallback scan"},indent=2),encoding="utf-8")
(OUT/"REMEDIATIONS.md").write_text("",encoding="utf-8")
print("OK scan (fallback)")
PY
            chmod +x scripts/collect_self_healing.py
          fi

          # auto_triage.py fallback
          if [ ! -f scripts/auto_triage.py ]; then
            cat > scripts/auto_triage.py <<'PY'
#\!/usr/bin/env python3
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
(OUT/"AUTO_TRIAGE_PLAN.json").write_text('{"remove_forbidden":[],"move_to_attic":[],"scaffold_dirs":[],"scaffold_files":[],"keep":[]}',encoding="utf-8")
(OUT/"AUTO_TRIAGE_REPORT.md").write_text("# Auto-Triage Plan\n\n- (fallback stub)\n",encoding="utf-8")
print("OK auto_triage (fallback)")
PY
            chmod +x scripts/auto_triage.py
          fi

      # --- Normalize/fix workflows first (auto-commit if requested) ---
      - name: Validate & Auto-Fix Workflows
        env:
          APPLY: ${{ github.event.inputs.auto_apply }}
        run: |
          set -e
          if [ "${APPLY}" = "true" ]; then
            python3 scripts/validate_and_fix.py --apply || true
          else
            python3 scripts/validate_and_fix.py || true
          fi

      - name: Commit Fixed Workflows (if auto_apply=true)
        if: ${{ github.event.inputs.auto_apply == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          git config user.name "workflow-fix-bot"
          git config user.email "bot@stegverse.local"
          git add .github/workflows/*.yml .github/workflows/*.yaml || true
          if git diff --cached --quiet; then
            echo "No workflow changes to commit."
          else
            git commit -m "chore: normalize workflows (auto-fix common YAML issues)"
            git push origin HEAD:main || true
          fi

      # --- Optional diagnostics against your API/worker ---
      - name: Runtime diagnostics (API + Worker)
        id: diag
        env:
          API_BASE: ${{ github.event.inputs.api_base }}
          QUEUE_KEY: ${{ github.event.inputs.queue_key }}
          TIMEOUT_SEC: ${{ github.event.inputs.timeout_sec }}
          POLL_SEC: ${{ github.event.inputs.poll_sec }}
        run: |
          set -euo pipefail
          API="${API_BASE}"
          if [ -z "$API" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            printf '{"ok":null,"skipped":true}\n' > supercheck_diag.json
            exit 0
          fi
          API="$(echo "$API" | sed 's:/*$::')"
          get(){ curl -sS -w "\n%{http_code}" "$1"; }
          post(){ curl -sS -w "\n%{http_code}" -X POST "$1" -H "Content-Type: application/json" -d "{}"; }
          pass=true; report='{"api_base":"'"$API"'","steps":[],"ok":false}'
          add(){ report=$(jq -c --arg n "$1" --argjson ok $2 --argjson data "$3" --arg e "${4:-}" '.steps += [{"name":$n,"ok":$ok,"data":$data,"error":(($e|length>0)?$e:null)}]' <<<"$report"); }
          read -r b s < <(get "$API/v1/ops/health");            if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/health" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/health" false null "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/env/required");      if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/env/required" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/env/required" false null "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/metrics");           if [ "${s:-500}" = "200" ]; then PB=$(echo "$b"|jq -r '.processed // 0'); add "GET /v1/ops/metrics (before)" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/metrics (before)" false null "HTTP $s"; pass=false; fi
          read -r b s < <(post "$API/v1/ops/queue/test");       if [ "${s:-500}" = "200" ] && [ "$(echo "$b"|jq -r '.queued // false')" = "true" ]; then add "POST /v1/ops/queue/test" true "$(echo "$b"|jq -S .)" ""; else add "POST /v1/ops/queue/test" false null "HTTP $s"; pass=false; fi
          end=$(( $(date +%s) + ${TIMEOUT_SEC} )); snaps="[]"; PA="$PB"
          if [ "$pass" = true ]; then
            while [ $(date +%s) -lt $end ]; do
              sleep "${POLL_SEC}"; read -r b s < <(get "$API/v1/ops/metrics")
              if [ "${s:-500}" = "200" ]; then snaps=$(jq -c --argjson s "$(echo "$b"|jq -S .)" '.+=[ $s ]' <<<"$snaps"); val=$(echo "$b"|jq -r '.processed // 0'); PA=$val; [ "$PA" -gt "$PB" ] && break; fi
            done
            ok=$([ "$PA" -gt "$PB" ] && echo true || echo false)
            add "Poll metrics until processed increases" "$ok" "$snaps" "before=$PB after=$PA timeout=${TIMEOUT_SEC}s"
            [ "$ok" = true ] || pass=false
          fi
          report=$(jq -c --argjson ok $([ "$pass" = true ] && echo true || echo false) '.ok=$ok' <<<"$report")
          echo "$report" | jq -S . > supercheck_diag.json
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "ok=$pass" >> $GITHUB_OUTPUT

      # --- Repo audit + drift + manifest (real scripts or fallbacks) ---
      - name: Repo Inventory & Diff
        run: python3 scripts/repo_audit.py

      - name: Topic Drift Auditor
        run: python3 scripts/topic_drift_audit.py

      - name: Self-Healing Scan (minimal)
        run: python3 scripts/collect_self_healing.py

      # --- Auto-triage (safe apply optional) ---
      - name: Auto-Triage (plan + optional apply)
        env:
          APPLY: ${{ github.event.inputs.auto_apply }}
        run: |
          set -e
          if [ "${APPLY}" = "true" ]; then
            APPLY=1 python3 scripts/auto_triage.py
          else
            python3 scripts/auto_triage.py
          fi

      # --- Commit/PR for triage if requested ---
      - name: Commit or PR changes
        if: ${{ github.event.inputs.auto_apply == 'true' }}
        env:
          DO_COMMIT: ${{ github.event.inputs.auto_commit }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          git config user.name "supercheck-bot"
          git config user.email "bot@stegverse.local"
          if [ "$DO_COMMIT" = "true" ]; then
            git add -A
            git commit -m "supercheck(auto): apply safe triage" || echo "No changes"
            git push origin HEAD:main || true
          else
            BR="supercheck/triage-${GITHUB_RUN_ID}"
            git checkout -b "$BR" || git checkout "$BR"
            git add -A
            git commit -m "supercheck(auto): apply safe triage" || echo "No changes"
            git push origin "$BR" || true
            TITLE="Supercheck: safe triage (auto)"
            BODY="This PR was created by One-Button Supercheck."
            curl -sS -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -nc --arg t "$TITLE" --arg b "$BODY" --arg head "$BR" '{"title":$t,"body":$b,"head":$head,"base":"main"}')" \
              "${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/pulls" >/dev/null || true

      # --- Always leave an artifact, even on failure ---
      - name: Ensure artifact dir & basic logs
        if: always()
        run: |
          set -e
          mkdir -p self_healing_out
          # Context snapshots
          echo "== runner env ==" > self_healing_out/RUN_ENV.txt
          env >> self_healing_out/RUN_ENV.txt
          echo "== git status ==" > self_healing_out/GIT_STATUS.txt
          git status >> self_healing_out/GIT_STATUS.txt 2>&1 || true
          echo "== tree (top) ==" > self_healing_out/TREE_TOP.txt
          ls -la >> self_healing_out/TREE_TOP.txt 2>&1 || true
          echo "== workflows dir ==" > self_healing_out/TREE_WORKFLOWS.txt
          ls -la .github/workflows >> self_healing_out/TREE_WORKFLOWS.txt 2>&1 || true
          echo "== scripts dir ==" > self_healing_out/TREE_SCRIPTS.txt
          ls -la scripts >> self_healing_out/TREE_SCRIPTS.txt 2>&1 || true
          # Drop placeholders if main reports are missing
          [ -f supercheck_report.md ] || echo "# Supercheck Report\n\n(No report produced—earlier step likely failed.)" > supercheck_report.md
          [ -f self_healing_out/WORKFLOW_FIX_REPORT.md ] || echo "# Workflow Fix Report\n\n(no report file)" > self_healing_out/WORKFLOW_FIX_REPORT.md

      - name: Assemble Supercheck Report
        if: always()
        run: |
          set -e
          # Build a single human-readable report (best-effort)
          {
            echo "# Supercheck Report"
            echo
            if [ -f supercheck_diag.json ]; then
              echo "## API/Worker Diagnostics"
              echo '```json'
              head -c 180000 supercheck_diag.json || true
              echo
              echo '```'
              echo
            fi
            echo "## Repo Inventory & Diff"
            echo
            cat self_healing_out/REPO_INVENTORY.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Drift Report"
            echo
            cat self_healing_out/DRIFT_REPORT.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Self-Healing Manifest"
            echo
            cat self_healing_out/SELF_HEALING_MANIFEST.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Auto-Triage Plan"
            echo
            cat self_healing_out/AUTO_TRIAGE_REPORT.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Workflow Fix Report"
            echo
            cat self_healing_out/WORKFLOW_FIX_REPORT.md 2>/dev/null || echo "(missing)"
          } > supercheck_report.md

      - name: Upload Supercheck Bundle (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: supercheck_bundle
          path: |
            supercheck_report.md
            supercheck_diag.json
            self_healing_out/**
          if-no-files-found: warn
