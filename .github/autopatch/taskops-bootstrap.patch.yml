version: 1
actions:
  - write_files:
      - path: ".github/taskops/tasks.yml"
        mode: "100644"
        contents: |
          version: 1
          meta:
            owner: StegVerse
            updated_at: 1970-01-01T00:00:00Z
            notes: |
              This file is the source of truth for TaskOps.
              Edit this file (not the README) to add/modify tasks.
          lanes:
            - id: autopatch
              title: AutoPatch & CI
              description: Tasks that evolve the patch runner and CI workflows.
            - id: hcb
              title: Hybrid Collab Bridge
              description: Tasks to evolve the hybrid-collab-bridge module and export.
            - id: docs
              title: Docs & Index
              description: Docs, READMEs, and repository index upkeep.
            - id: infra
              title: Infra & Self-Heal
              description: Watchdogs, reindex nudges, permissions, secrets.

          # Status buckets. Move items between these lists.
          # id: must be unique and stable; lane: one of the lanes above.
          open:
            - id: taskops-bootstrap
              lane: infra
              title: "Bootstrap TaskOps (tasks.yml + updater workflow + ledger)"
              detail: "Install TaskOps scaffolding so all change tasks are tracked, closed, and logged."
              created_at: 2025-10-11T00:00:00Z
              labels: [ "taskops", "infra" ]

            - id: export-hcb-live
              lane: hcb
              title: "Export hybrid-collab-bridge to StegVerse/hybrid-collab-bridge (live push)"
              detail: "Switch export-hcb from dry-run to direct push with version tag v1.2."
              created_at: 2025-10-11T00:00:00Z
              labels: [ "hcb", "export" ]

            - id: autopatch-manifest-unify
              lane: autopatch
              title: "Unify manifest entries and add comments for discoverability"
              detail: "Ensure patches.yml includes concise notes and IDs are consistent."
              created_at: 2025-10-11T00:00:00Z
              labels: [ "autopatch", "docs" ]

          in_progress:
            - id: watchdog-autodispatch
              lane: infra
              title: "Watchdog auto-dispatches reindex-nudge or autopatch-apply"
              detail: "Installed; verify it runs on schedule and opens issues on failure."
              created_at: 2025-10-11T00:00:00Z
              labels: [ "infra", "self-heal" ]

          blocked: []

          done:
            - id: reindex-nudge-installed
              lane: infra
              title: "Install reindex-nudge workflow"
              detail: "Adds .github/workflows/reindex-nudge.yml with safe timestamp push."
              created_at: 2025-10-11T00:00:00Z
              closed_at: 2025-10-11T00:00:00Z
              labels: [ "infra", "self-heal" ]

      - path: ".github/taskops/README-TASKOPS.md"
        mode: "100644"
        contents: |
          # ðŸ§­ TaskOps â€” StegVerse repo-level task tracker

          TaskOps is a repo-native, patch-friendly task system:
          - Source of truth: `.github/taskops/tasks.yml`
          - Append-only audit: `.github/taskops/ledger.jsonl`
          - Human view: this README (auto-updated by the workflow)
          - Script: `scripts/taskops_update.py`

          ## How to use
          1. **Edit** tasks in `.github/taskops/tasks.yml` (not here).
          2. Commit changes to `main`.
          3. Actions â†’ **taskops-update** runs and:
             - re-writes this README summary,
             - appends changes to the **ledger**, and
             - keeps a small `.state.json` for diffing.

          ## Buckets
          - `open` â†’ `in_progress` â†’ `done` or `blocked`
          - Each item: `{ id, lane, title, detail, created_at, [closed_at], labels[] }`

          ## Lanes
          - `autopatch` â€” patch runner & CI
          - `hcb` â€” hybrid-collab-bridge
          - `docs` â€” READMEs & indexes
          - `infra` â€” watchdogs, nudges, permissions

          ## Ledger format
          - JSON Lines (`.jsonl`): one event per line.
          - Events: `created`, `status_changed`, `updated`, `closed`.

          ---
          _This README is generated. Edit `tasks.yml`, not this file._

      - path: ".github/taskops/ledger.jsonl"
        mode: "100644"
        contents: ""

      - path: ".github/taskops/.state.json"
        mode: "100644"
        contents: |
          { "snapshot": null }

      - path: "scripts/taskops_update.py"
        mode: "100755"
        contents: |
          #!/usr/bin/env python3
          import json, sys, pathlib, copy, hashlib, datetime
          try:
              import yaml
          except Exception:
              print("PyYAML is required (pip install pyyaml)", file=sys.stderr)
              sys.exit(1)

          ROOT = pathlib.Path(".")
          TDIR = ROOT / ".github" / "taskops"
          TASKS = TDIR / "tasks.yml"
          LEDGER = TDIR / "ledger.jsonl"
          STATE = TDIR / ".state.json"
          README = TDIR / "README-TASKOPS.md"

          def now_iso():
              return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

          def load_yaml(p):
              return yaml.safe_load(p.read_text(encoding="utf-8"))

          def load_json(p):
              return json.loads(p.read_text(encoding="utf-8"))

          def write_json(p, obj):
              p.write_text(json.dumps(obj, indent=2, sort_keys=True), encoding="utf-8")

          def sha(obj):
              return hashlib.sha256(json.dumps(obj, sort_keys=True).encode()).hexdigest()

          def to_index(items):
              return { it["id"]: it for it in items }

          def flatten(tasks):
              all_items = []
              for bucket in ("open","in_progress","blocked","done"):
                  for it in tasks.get(bucket, []) or []:
                      x = copy.deepcopy(it)
                      x["_bucket"] = bucket
                      all_items.append(x)
              return all_items

          def summarize(tasks):
              txt = []
              lanes = {ln["id"]: ln for ln in tasks.get("lanes", [])}
              def lane_title(lid): return lanes.get(lid, {}).get("title", lid)

              counts = {b: len(tasks.get(b, []) or []) for b in ("open","in_progress","blocked","done")}
              txt.append(f"# ðŸ§­ TaskOps â€” Repo Tasks")
              txt.append("")
              txt.append(f"Updated: `{now_iso()}`  \nSource: `.github/taskops/tasks.yml`")
              txt.append("")
              txt.append("## Status")
              txt.append(f"- open: **{counts['open']}**")
              txt.append(f"- in_progress: **{counts['in_progress']}**")
              txt.append(f"- blocked: **{counts['blocked']}**")
              txt.append(f"- done: **{counts['done']}**")
              txt.append("")
              for bucket in ("open","in_progress","blocked","done"):
                  items = tasks.get(bucket, []) or []
                  if not items: continue
                  title = bucket.replace("_"," ").title()
                  txt.append(f"## {title}")
                  for it in items:
                      lid = it.get("lane","")
                      txt.append(f"- **{it['id']}** â€” _{lane_title(lid)}_: {it['title']}")
                      if it.get("labels"):
                          txt.append(f"  - labels: `{', '.join(it['labels'])}`")
                      if it.get("detail"):
                          txt.append(f"  - {it['detail']}")
                      if bucket == "done" and it.get("closed_at"):
                          txt.append(f"  - closed: `{it['closed_at']}`")
                  txt.append("")
              return "\n".join(txt).strip() + "\n"

          def diff_events(prev, curr):
              # Return ledger events between snapshots
              events = []
              pidx = {x["id"]: x for x in prev}
              cidx = {x["id"]: x for x in curr}

              # Created and updated
              for cid, item in cidx.items():
                  if cid not in pidx:
                      events.append({"type":"created","id":cid,"at":now_iso(),"item":item})
                  else:
                      # status change or any field differences (excluding timestamps)
                      pb = pidx[cid].get("_bucket"); cb = item.get("_bucket")
                      if pb != cb:
                          events.append({"type":"status_changed","id":cid,"at":now_iso(),"from":pb,"to":cb})
                      # any non-bucket content change?
                      pi = copy.deepcopy(pidx[cid]); ci = copy.deepcopy(item)
                      for k in ("_bucket",): pi.pop(k, None); ci.pop(k, None)
                      if sha(pi) != sha(ci):
                          events.append({"type":"updated","id":cid,"at":now_iso(),"item":item})

              # Closed
              for pid, pitem in pidx.items():
                  if pid not in cidx:
                      events.append({"type":"closed","id":pid,"at":now_iso(),"item":pitem})
              return events

          def main():
              if not TASKS.exists():
                  print("No tasks.yml found; nothing to do.")
                  return 0
              tasks = load_yaml(TASKS) or {}

              # Update meta timestamp
              tasks.setdefault("meta", {}).update({"updated_at": now_iso()})
              TASKS.write_text(yaml.safe_dump(tasks, sort_keys=False), encoding="utf-8")

              curr = flatten(tasks)
              prev = []
              if STATE.exists():
                  st = load_json(STATE)
                  if st.get("snapshot"):
                      prev = st["snapshot"]

              events = diff_events(prev, curr)
              if events:
                  with LEDGER.open("a", encoding="utf-8") as f:
                      for ev in events:
                          f.write(json.dumps(ev, sort_keys=True) + "\n")

              # Rewrite README summary
              README.write_text(summarize(tasks), encoding="utf-8")

              # Save snapshot
              write_json(STATE, {"snapshot": curr})

              print(f"[taskops] events: {len(events)}; snapshot size: {len(curr)}")
              return 0

          if __name__ == "__main__":
              sys.exit(main())

      - path: ".github/workflows/taskops-update.yml"
        mode: "100644"
        contents: |
          name: taskops-update
          on:
            workflow_dispatch: {}
            push:
              branches: [ "main" ]
              paths:
                - ".github/taskops/tasks.yml"
                - "scripts/taskops_update.py"
            schedule:
              - cron: "13 3 * * *"  # daily @ 03:13 UTC

          permissions:
            contents: write

          jobs:
            update:
              runs-on: ubuntu-latest
              steps:
                - name: Checkout
                  uses: actions/checkout@v4
                  with:
                    persist-credentials: true
                    fetch-depth: 0

                - name: Setup Python
                  uses: actions/setup-python@v5
                  with:
                    python-version: "3.x"

                - name: Install deps
                  run: |
                    python -m pip install --upgrade pip
                    pip install pyyaml

                - name: Run TaskOps updater
                  run: |
                    python scripts/taskops_update.py

                - name: Commit changes (ledger/readme/state)
                  run: |
                    set -euo pipefail
                    git config user.name "StegVerse Bot"
                    git config user.email "bot@stegverse.org"
                    git add .github/taskops/README-TASKOPS.md \
                            .github/taskops/ledger.jsonl \
                            .github/taskops/.state.json \
                            .github/taskops/tasks.yml || true
                    if git diff --cached --quiet; then
                      echo "No TaskOps changes to commit."
                    else
                      git commit -m "chore(taskops): update README & ledger"
                      git push origin HEAD:main
                    fi

                - name: Summary
                  run: echo "âœ… TaskOps update complete."

  - commit:
      message: "chore(taskops): bootstrap TaskOps (tasks.yml, updater, ledger, workflow)"
