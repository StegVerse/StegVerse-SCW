name: Rebuild Kit (Zero-Secret, Auto-Healed, With Breadcrumbs)

on:
  push:
    paths:
      - ".github/trigger/rebuild/**"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  rebuild:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y zip jq || true
          python3 -V

      # --- Fix-It precision scan (if script exists) ---
      - name: Run Fix-It (precision repair)
        run: |
          mkdir -p self_healing_out
          if [ -f scripts/validate_and_fix.py ]; then
            python3 scripts/validate_and_fix.py --apply || true
          fi

      # --- Sweep-All broad scan (if script exists) ---
      - name: Run Sweep-All (broad repair)
        run: |
          mkdir -p self_healing_out
          if [ -f scripts/sweep_all_workflows.py ]; then
            python3 scripts/sweep_all_workflows.py --apply || true
          fi

      # --- Breadcrumb logger ---
      - name: Log trigger metadata
        run: |
          mkdir -p self_healing_out
          TS="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          SHA="$(git rev-parse --short HEAD)"
          LOG_JSON="self_healing_out/REBUILD_TRIGGER_LOG.json"
          LOG_MD="self_healing_out/REBUILD_TRIGGER_LOG.md"
          jq -n --arg ts "$TS" --arg sha "$SHA" --arg repo "$GITHUB_REPOSITORY" \
            --arg run_url "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" \
            --argjson triggers "$(jq -R -s -c 'split("\n")|map(select(length>0))' <<< "$(cat .github/trigger/rebuild/* 2>/dev/null || true)")" \
            '{repo:$repo, sha:$sha, timestamp:$ts, run_url:$run_url, triggers:$triggers}' > "$LOG_JSON"
          echo "# Rebuild Trigger Log" > "$LOG_MD"
          echo "- Repo: $GITHUB_REPOSITORY" >> "$LOG_MD"
          echo "- Commit: $SHA" >> "$LOG_MD"
          echo "- Timestamp: $TS" >> "$LOG_MD"
          echo "- Run: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" >> "$LOG_MD"
          echo "- Trigger files:" >> "$LOG_MD"
          for f in .github/trigger/rebuild/*; do
            [ -f "$f" ] || continue
            echo "  - $f" >> "$LOG_MD"
            echo "    \`\`\`" >> "$LOG_MD"
            cat "$f" >> "$LOG_MD"
            echo "    \`\`\`" >> "$LOG_MD"
          done

      - name: Seed bundle script if missing
        run: |
          set -euo pipefail
          mkdir -p scripts
          if [ ! -f scripts/make_rebuild_bundle.sh ]; then
            cat > scripts/make_rebuild_bundle.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail

ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )/.." && pwd )"
OUT_DIR="$ROOT/out"
WORK_DIR="$ROOT/bundle"
TS="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
SHA="$(git rev-parse --short HEAD 2>/dev/null || echo unknown)"
BRANCH="${GITHUB_REF_NAME:-$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo unknown)}"

rm -rf "$OUT_DIR" "$WORK_DIR"
mkdir -p "$OUT_DIR" "$WORK_DIR"

copy_if() { [ -e "$1" ] && (mkdir -p "$WORK_DIR/$(dirname "$1")"; cp -R "$1" "$WORK_DIR/$1"); }

# Include key areas if they exist
copy_if ".github/workflows"
copy_if "scripts"
copy_if "self_healing_out"
copy_if "infra"
copy_if "api"
copy_if "public"
copy_if "docs"
copy_if "README.md"

# Always include trigger logs
copy_if "self_healing_out/REBUILD_TRIGGER_LOG.json"
copy_if "self_healing_out/REBUILD_TRIGGER_LOG.md"

# If nothing got copied, create a placeholder
if [ -z "$(ls -A "$WORK_DIR" 2>/dev/null)" ]; then
  echo "# Rebuild Kit placeholder" > "$WORK_DIR/README_REBUILD_KIT.md"
fi

# Create manifest
mkdir -p "$WORK_DIR/_manifest"
cat > "$WORK_DIR/_manifest/MANIFEST.json" <<JSON
{
  "repo": "${GITHUB_REPOSITORY:-unknown}",
  "sha": "${SHA}",
  "branch": "${BRANCH}",
  "generated_at": "${TS}",
  "counts": {
    "files_in_bundle": $(find "$WORK_DIR" -type f | wc -l | tr -d ' ')
  },
  "notes": [
    "This archive was produced after Fix-It + Sweep-All auto-healing.",
    "Includes breadcrumb trigger logs for traceability."
  ]
}
JSON

# Prefer zip; fallback to tar.gz
BASENAME="rebuild_kit_${SHA}_${TS//[:]/}"
if command -v zip >/dev/null 2>&1; then
  (cd "$WORK_DIR" && zip -r "../out/${BASENAME}.zip" . >/dev/null)
  echo "out/${BASENAME}.zip" > "$OUT_DIR/.bundle_path"
else
  tar -C "$WORK_DIR" -czf "$OUT_DIR/${BASENAME}.tgz" .
  echo "out/${BASENAME}.tgz" > "$OUT_DIR/.bundle_path"
fi

ln -sf "$(cat "$OUT_DIR/.bundle_path")" "$OUT_DIR/latest"

echo "Bundle created: $(cat "$OUT_DIR/.bundle_path")"
ls -lh "$OUT_DIR"
SH
          fi

      - name: Normalize line endings & make executable
        run: |
          sed -i 's/\r$//' scripts/make_rebuild_bundle.sh || true
          chmod +x scripts/make_rebuild_bundle.sh

      - name: Build bundle
        run: |
          set -euo pipefail
          bash -x scripts/make_rebuild_bundle.sh
          echo "BUNDLE_PATH=$(cat out/.bundle_path)" >> $GITHUB_ENV

      - name: Ensure there is *some* file to upload
        run: |
          if [ ! -f "${BUNDLE_PATH}" ]; then
            echo "No bundle found at ${BUNDLE_PATH}. Creating placeholder."
            echo "empty" > out/EMPTY.txt
            echo "BUNDLE_PATH=out/EMPTY.txt" >> $GITHUB_ENV
          fi

      - name: Upload bundle artifact
        uses: actions/upload-artifact@v4
        with:
          name: rebuild_kit_bundle
          path: ${{ env.BUNDLE_PATH }}
          if-no-files-found: warn
