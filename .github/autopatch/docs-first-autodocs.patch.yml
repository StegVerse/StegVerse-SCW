version: 1
actions:
  - write_files:
      - path: "scripts/autodocs_generate.py"
        mode: "100755"
        contents: |
          #!/usr/bin/env python3
          """
          AutoDocs generator (docs-first)
          - Builds a small status block for README.md (between <!-- autodocs:start --> / <!-- autodocs:end -->)
          - Writes the full operator guide to .github/docs/AUTOPATCH_GUIDE.md
          - Sources data from .github/taskops/ledger.jsonl (best-effort)
          - Idempotent: safe to re-run, and no change = no diff
          """
          import json, pathlib, datetime
          from collections import Counter

          ROOT = pathlib.Path(".")
          LEDGER = ROOT / ".github" / "taskops" / "ledger.jsonl"
          DOCS_DIR = ROOT / ".github" / "docs"
          TARGET_DOC = DOCS_DIR / "AUTOPATCH_GUIDE.md"
          README = ROOT / "README.md"

          START = "<!-- autodocs:start -->"
          END   = "<!-- autodocs:end -->"
          NOW = datetime.datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

          def read_ledger():
              if not LEDGER.exists():
                  return []
              out = []
              with LEDGER.open("r", encoding="utf-8", errors="ignore") as f:
                  for line in f:
                      line = line.strip()
                      if not line: 
                          continue
                      try:
                          j = json.loads(line)
                          if isinstance(j, dict):
                              out.append(j)
                      except Exception:
                          continue
              # sort ascending by ts if present
              out.sort(key=lambda x: x.get("ts",""))
              return out

          def rollup_autopatch(items):
              # aggregate simple counts if present in ledger lines
              agg = {"applied":0, "noop":0, "skipped":0, "blocked":0, "error":0}
              for x in items:
                  if x.get("job") == "autopatch-apply":
                      for k in list(agg.keys()):
                          try:
                              agg[k] += int(str(x.get(k,"0") or "0"))
                          except Exception:
                              pass
              return agg

          def ensure_readme_slot():
              txt = README.read_text(encoding="utf-8") if README.exists() else ""
              if START in txt and END in txt:
                  return
              # append a minimal slot
              README.parent.mkdir(parents=True, exist_ok=True)
              with README.open("a", encoding="utf-8") as w:
                  if txt and not txt.endswith("\n"):
                      w.write("\n")
                  w.write("\n## Ops status\n")
                  w.write(f"{START}\n")
                  w.write("_No data yet — run **AutoDocs (on-demand)**._\n")
                  w.write(f"{END}\n")

          def write_readme_block(block_md: str):
              txt = README.read_text(encoding="utf-8")
              pre, sep, tail = txt.partition(START)
              if not sep:
                  # slot was just created above; read again
                  ensure_readme_slot()
                  txt = README.read_text(encoding="utf-8")
                  pre, _, tail = txt.partition(START)
              _, sep2, post = tail.partition(END)
              README.write_text(pre + START + "\n" + block_md + "\n" + END + post, encoding="utf-8")

          def render_readme_block(agg, last10):
              lines = []
              lines.append(f"_Last updated: **{NOW}**_")
              if sum(agg.values()) > 0:
                  lines.append(
                      f"\n- AutoPatch totals → ✅ **{agg['applied']}** · ⏭ **{agg['noop']}** · ⚠️ **{agg['skipped']}** · ⛔ **{agg['blocked']}** · ❌ **{agg['error']}**"
                  )
              if last10:
                  lines.append("\n**Latest 10 ledger entries**")
                  lines.append("| ts (UTC) | job | branch | run_id |")
                  lines.append("|---|---|---|---:|")
                  for x in last10:
                      ts = x.get("ts","")
                      job = x.get("job","")
                      br  = x.get("branch","")
                      rid = str(x.get("run_id",""))
                      lines.append(f"| {ts} | `{job}` | `{br}` | {rid} |")
              else:
                  lines.append("\n_No ledger data yet._")
              return "\n".join(lines) + "\n"

          def render_full_guide():
              return f"""# AutoPatch Operator Guide (Docs-First)

This guide is generated by **AutoDocs** and kept in sync with your repo.

## How to Run a Patch

### Manual
1. Open **Actions → autopatch-apply**
2. Click **Run workflow**

Or use the consolidated **Ops Console** (if present).

### Automatic
A push under `.github/autopatch/**` normally triggers an apply run.

---

## Best Practices
- Keep patches **small**, **modular**, and **idempotent**.
- Include marker files (e.g., `.applied_xyz`) for easy “was this applied?” checks.
- Document reasons right in `patches.yml` with short comments.
- Archive deprecated patches under `/ATTIC/` (or mark them deferred).

---

## Architecture Layers

| Layer | Purpose |
|:--|:--|
| `.github/autopatch/` | Meta layer—patches, manifests, self-healing helpers |
| `.github/workflows/` | Operational layer—build, docs, export, etc. |
| `.github/taskops/` | Governance/logging—`ledger.jsonl`, reports |

---

## Versioning & Traceability
Each AutoPatch run appends a line to:  
`.github/taskops/ledger.jsonl` (timestamp, job, branch, run_id, and counts when available).

AutoDocs uses this ledger to refresh the README status and this guide.

---

## Maintainer Tip
If the **Run workflow** button ever disappears for key workflows:
- Run **workflow-dispatch-guardian.yml**, _or_
- Trigger **Ops Console**

Either action restores missing `workflow_dispatch` entries automatically.

_Last generated: **{NOW}**_
"""

          def main():
              ensure_readme_slot()
              items = read_ledger()
              agg = rollup_autopatch(items)
              last10 = list(reversed(items))[:10]

              # write README block
              readme_block = render_readme_block(agg, last10)
              write_readme_block(readme_block)

              # write full guide
              DOCS_DIR.mkdir(parents=True, exist_ok=True)
              TARGET_DOC.write_text(render_full_guide(), encoding="utf-8")

              print("[autodocs] README status + AUTOPATCH_GUIDE.md updated.")

          if __name__ == "__main__":
              main()
      - path: ".github/docs/.keep"
        mode: "100644"
        contents: ""
  - run_shell:
      name: Generate docs now (best-effort)
      script: |
        set -euo pipefail
        python3 --version || true
        python3 scripts/autodocs_generate.py || true
  - commit:
      message: "docs(autopatch): switch to docs-first (README status + AUTOPATCH_GUIDE.md)"
