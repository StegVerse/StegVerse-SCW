name: Emergency Orchestrator LITE (direct apply)
on: { workflow_dispatch: {} }

permissions:
  contents: write

jobs:
  fix_and_install:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 2 }

      - name: Neutralize `if: ${{ secrets… }}` in all workflows
        shell: bash
        run: |
          set -euo pipefail
          changed=0
          patch() {
            local wf="$1"
            awk '
              {
                if ($0 ~ /^[[:space:]]*if:[[:space:]]*\$\{\{[[:space:]]*secrets\.[^}]+\}\}[[:space:]]*$/) {
                  indent = match($0,/^[[:space:]]*/)
                  spaces = substr($0,1,RLENGTH)
                  print spaces "# TODO(auto): secrets-guard disabled to avoid parser error"
                  print spaces "# " $0
                  print spaces "if: ${{ false }}"
                  next
                }
              }
              { print }
            ' "$wf" > "$wf.tmp" && mv "$wf.tmp" "$wf"
          }
          for wf in .github/workflows/*.yml .github/workflows/*.yaml; do
            [ -f "$wf" ] || continue
            if grep -nE '^[[:space:]]*if:[[:space:]]*\$\{\{[[:space:]]*secrets\.[^}]+' "$wf" >/dev/null 2>&1; then
              patch "$wf"
              git add "$wf"
              changed=$((changed+1))
            fi
          done
          echo "NEUTRAL_CHANGED=$changed" >> $GITHUB_ENV

      - name: Fix known collector typo; normalize; ensure exec bits
        shell: bash
        run: |
          set -euo pipefail
          # fix the GAPS.json line if present
          if [ -f scripts/collect_self_healing.py ]; then
            sed -i 's/json.dumps(manifest "gaps"].*/json.dumps(manifest["gaps"], indent=2), encoding="utf-8")/' scripts/collect_self_healing.py || true
            git add scripts/collect_self_healing.py || true
          fi
          # normalize line endings
          while IFS= read -r -d '' f; do
            perl -pi -e 's/\r$//' "$f"
            git add "$f"
          done < <(git ls-files -z '*.sh' '*.py' '.github/workflows/*.yml' '.github/workflows/*.yaml')
          # ensure .sh are executable
          chmod +x scripts/*.sh 2>/dev/null || true
          git add scripts/*.sh 2>/dev/null || true

      - name: Install self-healing pack (scanner, fixer, rebuild kit) if missing
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p scripts .github/workflows

          # make_rebuild_bundle.sh
          if [ ! -f scripts/make_rebuild_bundle.sh ]; then
            cat > scripts/make_rebuild_bundle.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail
SHA="${1:-$(git rev-parse HEAD)}"; PREV="${2:-$(git rev-parse HEAD~1)}"; OUTDIR="${3:-rebuild_kit}"
REPO_NAME="${4:-$(basename "$(git rev-parse --show-toplevel)")}"
DATE_ISO="$(date -u +%Y-%m-%dT%H:%M:%SZ)"; mkdir -p "$OUTDIR"
{ echo "repo: $REPO_NAME"; echo "date_utc: $DATE_ISO"; echo "commit_sha: $SHA"; echo "prev_sha: $PREV"; echo "branch: ${GITHUB_REF_NAME:-$(git rev-parse --abbrev-ref HEAD)}"; } > "$OUTDIR/meta.txt"
git diff --name-status "$PREV" "$SHA" > "$OUTDIR/changed_files.txt" || true
git diff -U3 "$PREV" "$SHA" > "$OUTDIR/changes.patch" || true
mkdir -p "$OUTDIR/files"
awk '{ if ($1=="A" || $1=="M" || $1=="R100" || $1=="R") print $NF }' "$OUTDIR/changed_files.txt" | while read -r f; do
  [ -f "$f" ] && mkdir -p "$OUTDIR/files/$(dirname "$f")" && cp -a "$f" "$OUTDIR/files/$f"
done
CRIT=( "api/app/main.py" "api/requirements.txt" "public/diag.html" "render.yaml" "package.json" "pnpm-lock.yaml" "yarn.lock" "package-lock.json" ".github/workflows" )
for p in "${CRIT[@]}"; do [ -e "$p" ] && mkdir -p "$OUTDIR/crit/$(dirname "$p")" && cp -a "$p" "$OUTDIR/crit/$p" || true; done
( cd "$OUTDIR" && find files crit -type f 2>/dev/null | LC_ALL=C sort | xargs -r sha256sum > file_hashes.sha256 )
( tree -L 3 -a -I '.git|node_modules|__pycache__' > "$OUTDIR/tree.txt" ) || ( find . -maxdepth 3 -type f -printf "%TY-%Tm-%Td %p\n" | sort -r > "$OUTDIR/tree.txt" )
cat > "$OUTDIR/README-RECOVERY.md" <<'REC'
# Rebuild Kit
Fast: rsync -a files/ .
Patch: git apply --whitespace=fix changes.patch
REC
ZIP="rebuild_kit_${REPO_NAME}_$(git rev-parse --short "$SHA").zip"
( cd "$OUTDIR/.." && zip -r "$ZIP" "$(basename "$OUTDIR")" >/dev/null )
echo "$ZIP"
SH
            chmod +x scripts/make_rebuild_bundle.sh
            git add scripts/make_rebuild_bundle.sh
          fi

          # collect_self_healing.py
          if [ ! -f scripts/collect_self_healing.py ]; then
            cat > scripts/collect_self_healing.py <<'PY'
#!/usr/bin/env python3
import os, hashlib, json, re, datetime, subprocess
from pathlib import Path
ROOT = Path(__file__).resolve().parents[1]
OUT = ROOT / "self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
def sh(*cmd): return subprocess.check_output(cmd, cwd=str(ROOT), text=True).strip()
def sha(p):
    h=hashlib.sha256()
    with open(p,'rb') as f:
        for b in iter(lambda:f.read(65536),b''): h.update(b)
    return h.hexdigest()
def txt(p,lim=None):
    try:
        t=Path(p).read_text(encoding='utf-8',errors='ignore')
        return t if not lim or len(t)<=lim else t[:lim]+"\n... [truncated] ..."
    except Exception as e: return f"[error reading {p}: {e}]"
def files(glob_pat): return sorted([str(p) for p in ROOT.glob(glob_pat) if p.is_file()])
def commits(n=30):
    try: return sh("git","log","--pretty=format:%ad %h %s","--date=iso",f"-{n}").splitlines()
    except: return []
def detect_measures():
    ms=[]
    for wf in files(".github/workflows/*.yml")+files(".github/workflows/*.yaml"):
        t=txt(wf)
        kinds=[]
        if re.search(r"Rebuild Kit",t,re.I) or "make_rebuild_bundle.sh" in t: kinds.append("rebuild_kit")
        if re.search(r"Configure & Deploy|Render.*deploy|resume",t,re.I): kinds.append("deploy_automation")
        if re.search(r"Health & Report|Wait for health|HEALTH_URL",t,re.I): kinds.append("health_check")
        if re.search(r"Self-Healing Scan|Repo Timeline|inventory",t,re.I): kinds.append("timeline_inventory")
        if re.search(r"Snapshot Release",t,re.I): kinds.append("snapshot_release")
        ms.append({"type":"workflow","path":wf,"kinds":kinds or ["other"],"sha256":sha(wf)})
    for s in files("scripts/*.sh")+files("scripts/*.py"):
        ms.append({"type":"script","path":s,"sha256":sha(s)})
    api = ROOT/"api/app/main.py"
    if api.exists():
        t=txt(api)
        ms.append({"type":"api","path":str(api),"sha256":sha(api),
                   "has_health":"/v1/ops/health" in t,
                   "has_deploy_report":"/v1/ops/deploy/report" in t,
                   "has_env_presence":"/v1/ops/env/required" in t})
    diag = ROOT/"public/diag.html"
    if diag.exists(): ms.append({"type":"ui","path":str(diag),"sha256":sha(diag)})
    for c in ["render.yaml","api/requirements.txt","package.json","pnpm-lock.yaml","yarn.lock","package-lock.json"]:
        p=ROOT/c
        if p.exists(): ms.append({"type":"config","path":str(p),"sha256":sha(p)})
    return ms
def gaps(ms):
    paths={m["path"] for m in ms}
    missing, warn = [], []
    common_scripts = ["scripts/make_rebuild_bundle.sh","scripts/collect_self_healing.py"]
    common_wf = [".github/workflows/rebuild-kit.yml",".github/workflows/self-healing-scan.yml"]
    for p in common_scripts:
        if p not in paths: missing.append({"category":"script","path":p})
    for p in common_wf:
        if p not in paths: missing.append({"category":"workflow","path":p})
    if (ROOT/"api/app/main.py").exists():
        for p in ["api/app/main.py","api/requirements.txt","public/diag.html"]:
            if p not in paths: missing.append({"category":"file","path":p})
        if not any(w in paths for w in [".github/workflows/scw-api-config-and-deploy.yml",".github/workflows/scw-api-health-and-report.yml"]):
            missing.append({"category":"workflow","path":"(one of) .github/workflows/scw-api-config-and-deploy.yml, .github/workflows/scw-api-health-and-report.yml"})
        api = next((m for m in ms if m.get("type")=="api"), None)
        if api:
            if not api.get("has_health"): warn.append("api missing /v1/ops/health")
            if not api.get("has_deploy_report"): warn.append("api missing /v1/ops/deploy/report")
            if not api.get("has_env_presence"): warn.append("api missing /v1/ops/env/required")
    return {"missing":missing,"warnings":warn}
def write_all(manifest):
    (OUT/"SELF_HEALING_MANIFEST.json").write_text(json.dumps(manifest,indent=2),encoding="utf-8")
    md=[]
    md+= [f"# Self-Healing Manifest — {manifest['repo']} ({manifest['branch']})",
          f"- Generated: **{manifest['generated_at']}**",
          f"- Commit: `{manifest['commit']}`  Prev: `{manifest.get('prev','')}`","",
          "## Detected Measures"]
    for m in manifest["measures"]:
        extra=""
        if m["type"]=="workflow" and m.get("kinds"): extra=f" • kinds: {', '.join(m['kinds'])}"
        if m["type"]=="api":
            flags=[]
            if m.get("has_health"): flags.append("health")
            if m.get("has_deploy_report"): flags.append("deploy_report")
            if m.get("has_env_presence"): flags.append("env_presence")
            if flags: extra += f" • features: {', '.join(flags)}"
        md.append(f"- **{m['type']}** `{m['path']}` (sha256 `{m['sha256'][:12]}…`){extra}")
    md.append("\n## Gaps Detected")
    if not manifest["gaps"]["missing"] and not manifest["gaps"]["warnings"]:
        md.append("- ✅ No gaps detected.")
    else:
        for g in manifest["gaps"]["missing"]: md.append(f"- ❌ MISSING {g['category']}: `{g['path']}`")
        for w in manifest["gaps"]["warnings"]: md.append(f"- ⚠️ {w}")
    md.append("\n## Recent Commits")
    for c in manifest["recent_commits"]: md.append(f"- {c}")
    (OUT/"SELF_HEALING_MANIFEST.md").write_text("\n".join(md),encoding="utf-8")
    (OUT/"index.json").write_text(json.dumps({"repo":manifest["repo"],"commit":manifest["commit"],"generated_at":manifest["generated_at"],"measures_count":len(manifest["measures"]), "missing_count":len(manifest['gaps']['missing'])}),encoding="utf-8")
    (OUT/"GAPS.json").write_text(json.dumps(manifest["gaps"], indent=2), encoding="utf-8")
    if not (OUT/"REMEDIATIONS.md").exists():
        (OUT/"REMEDIATIONS.md").write_text("",encoding="utf-8")
def main():
    try: commit = sh("git","rev-parse","HEAD"); prev=sh("git","rev-parse","HEAD~1")
    except: commit, prev = "HEAD","HEAD~1"
    branch = os.getenv("GITHUB_REF_NAME") or sh("git","rev-parse","--abbrev-ref","HEAD")
    repo = os.getenv("GITHUB_REPOSITORY") or ROOT.name
    ms = detect_measures()
    gs = gaps(ms)
    manifest = {"repo":repo,"branch":branch,"commit":commit,"prev":prev,"generated_at":datetime.datetime.utcnow().isoformat()+"Z","measures":ms,"gaps":gs,"recent_commits":commits(30)}
    write_all(manifest)
    print(str(OUT/"SELF_HEALING_MANIFEST.json"))
if __name__=="__main__": main()
PY
            git add scripts/collect_self_healing.py
          fi

          # workflows: self-healing-scan.yml
          if [ ! -f .github/workflows/self-healing-scan.yml ]; then
            cat > .github/workflows/self-healing-scan.yml <<'YML'
name: Self-Healing Scan (+ optional fixes)
on:
  workflow_dispatch:
    inputs:
      auto_fix:
        description: 'Apply canonical fixes (writes files & logs)'
        required: false
        default: 'false'
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/**'
      - 'scripts/**'
      - 'api/**'
      - 'public/diag.html'
      - 'render.yaml'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'yarn.lock'
      - 'package-lock.json'
jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 2 }
      - name: Run scanner
        run: python3 scripts/collect_self_healing.py
      - name: Apply fixes
        if: ${{ github.event.inputs.auto_fix == 'true' }}
        run: python3 scripts/apply_canonical_fixes.py
      - name: Re-scan (post-fix)
        if: ${{ github.event.inputs.auto_fix == 'true' }}
        run: python3 scripts/collect_self_healing.py
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: self_healing_manifest
          path: |
            self_healing_out/SELF_HEALING_MANIFEST.json
            self_healing_out/SELF_HEALING_MANIFEST.md
            self_healing_out/index.json
            self_healing_out/GAPS.json
            self_healing_out/REMEDIATIONS.md
          if-no-files-found: error
YML
            git add .github/workflows/self-healing-scan.yml
          fi

          # workflows: rebuild-kit.yml
          if [ ! -f .github/workflows/rebuild-kit.yml ]; then
            cat > .github/workflows/rebuild-kit.yml <<'YML'
name: Rebuild Kit (Zero-Secret)
on:
  push: { branches: [ main ] }
  workflow_dispatch: {}
jobs:
  bundle:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 2 }
      - name: Build Rebuild Kit
        run: |
          bash scripts/make_rebuild_bundle.sh "$(git rev-parse HEAD)" "$(git rev-parse HEAD~1 || echo HEAD)" "rebuild_kit" "$(basename "$GITHUB_REPOSITORY")" > zipname.txt || {
            chmod +x scripts/make_rebuild_bundle.sh || true
            bash scripts/make_rebuild_bundle.sh "$(git rev-parse HEAD)" "$(git rev-parse HEAD~1 || echo HEAD)" "rebuild_kit" "$(basename "$GITHUB_REPOSITORY")" > zipname.txt
          }
          cat zipname.txt
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with: { name: rebuild_kit, path: ./*.zip, if-no-files-found: error }
YML
            git add .github/workflows/rebuild-kit.yml
          fi

      - name: Commit & push to main
        run: |
          git config user.name "automation-bot"
          git config user.email "bot@stegverse.local"
          git commit -m "Orchestrator LITE: neutralize secrets-if, hygiene, install self-healing pack" || echo "No changes"
          git push origin HEAD:main
