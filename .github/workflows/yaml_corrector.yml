#!/usr/bin/env python3
"""
YAML Corrector v2 — StegVerse

Rules applied:
- RULE-EMBEDDED-PY-NOT-IN-RUN: Move embedded code blocks into `run: |` for steps.
- RULE-CHECKOUT-CLEAN: Enforce clean checkout with fetch-depth=1.
- RULE-IFNOFILESFOUND: Ensure upload-artifact uses if-no-files-found: warn.

Usage:
  python3 scripts/yaml_corrector_v2.py           # dry run
  python3 scripts/yaml_corrector_v2.py --apply   # write changes

Writes report to self_healing_out/YAML_CORRECTOR_REPORT.{json,md}
"""
from ruamel.yaml import YAML
from ruamel.yaml.scalarstring import LiteralScalarString
from pathlib import Path
import re, json, sys, copy, time

ROOT = Path(__file__).resolve().parents[1]
WF = ROOT / ".github" / "workflows"
OUT = ROOT / "self_healing_out"
OUT.mkdir(parents=True, exist_ok=True)

yaml = YAML()
yaml.preserve_quotes = True
yaml.indent(mapping=2, sequence=2, offset=2)

CODE_HINTS = re.compile(
    r"(^\s*#!/usr/bin/env\s+(bash|python)\b)|(^\s*set\s+-e)|(^\s*import\s+\w+)|(^\s*from\s+\w+\s+import)|(^\s*python3\s+-m)|(^\s*curl\s+-sS)|(^\s*echo\s+)",
    re.M
)

def is_embedded_code_value(val: str) -> bool:
    if not isinstance(val, str):
        return False
    return bool(CODE_HINTS.search(val))

def normalize_checkout(step: dict, changes: list):
    uses = step.get('uses', '')
    if isinstance(uses, str) and uses.startswith('actions/checkout@'):
        withs = step.setdefault('with', {})
        if not isinstance(withs, dict):
            withs = {}
            step['with'] = withs
        updated = False
        if withs.get('clean') != True:
            withs['clean'] = True
            updated = True
        if withs.get('fetch-depth') not in (1, '1'):
            withs['fetch-depth'] = 1
            updated = True
        if updated:
            changes.append("RULE-CHECKOUT-CLEAN")

def ensure_if_no_files_found(step: dict, changes: list):
    uses = step.get('uses', '')
    if isinstance(uses, str) and uses.startswith('actions/upload-artifact@'):
        withs = step.setdefault('with', {})
        if not isinstance(withs, dict):
            withs = {}
            step['with'] = withs
        if withs.get('if-no-files-found') not in ('warn', 'ignore', 'error'):
            withs['if-no-files-found'] = 'warn'
            changes.append("RULE-IFNOFILESFOUND")

def fix_embedded_code(step: dict, changes: list):
    """
    Detect common mistakes where a multi-line code block was placed as a
    random key instead of `run:`. We:
      - collect suspicious string values
      - move them into `run: |` (joined with newlines if several)
      - delete those stray keys
    """
    if 'run' in step:
        return  # already correct

    stray_keys = []
    code_snips = []

    # scan fields except special known keys
    special = {'name','uses','with','env','id','if','shell','working-directory','timeout-minutes','continue-on-error'}
    for k, v in list(step.items()):
        if k in special:
            continue
        if isinstance(v, str) and is_embedded_code_value(v):
            stray_keys.append(k)
            code_snips.append(v)

    if not code_snips:
        return

    joined = "\n\n".join(code_snips)
    step['run'] = LiteralScalarString(joined)
    # delete stray keys
    for k in stray_keys:
        try:
            del step[k]
        except Exception:
            pass
    changes.append("RULE-EMBEDDED-PY-NOT-IN-RUN")

def process_workflow(path: Path):
    data = yaml.load(path.read_text(encoding='utf-8'))
    before = copy.deepcopy(data)
    changed = []
    errors = []

    try:
        jobs = data.get('jobs', {})
        if isinstance(jobs, dict):
            for job_id, job in jobs.items():
                steps = job.get('steps', [])
                if not isinstance(steps, list): continue
                for step in steps:
                    if not isinstance(step, dict): continue
                    # normalize actions/checkout
                    normalize_checkout(step, changed)
                    # ensure upload-artifact flag
                    ensure_if_no_files_found(step, changed)
                    # move embedded code into run
                    fix_embedded_code(step, changed)
    except Exception as e:
        errors.append(f"walk-error: {e}")

    touched = bool(changed)
    return data, touched, changed, errors

def main(apply=False):
    results = []
    for p in sorted(WF.glob("*.y*ml")):
        try:
            fixed, touched, rules, errs = process_workflow(p)
            if apply and touched:
                yaml.dump(fixed, p.open("w", encoding="utf-8"))
            results.append({
                "path": p.as_posix(),
                "changed": touched,
                "rules_applied": sorted(set(rules)),
                "errors": errs
            })
        except Exception as e:
            results.append({
                "path": p.as_posix(),
                "changed": False,
                "rules_applied": [],
                "errors": [f"load-error: {e}"]
            })

    summary = {
        "ts": int(time.time()),
        "apply": apply,
        "files": len(results),
        "changed": sum(1 for r in results if r["changed"]),
        "rule_counts": {}
    }
    for r in results:
        for ru in r["rules_applied"]:
            summary["rule_counts"][ru] = summary["rule_counts"].get(ru, 0) + 1

    # write reports
    (OUT/"YAML_CORRECTOR_REPORT.json").write_text(json.dumps({"summary": summary, "results": results}, indent=2), encoding="utf-8")
    md = ["# YAML Corrector Report",
          f"- Time: {summary['ts']}",
          f"- Files scanned: **{summary['files']}**",
          f"- Files changed: **{summary['changed']}**"]
    if summary["rule_counts"]:
        md.append("\n## Rules Applied")
        for k,v in sorted(summary["rule_counts"].items()):
            md.append(f"- **{k}** × {v}")
    if any(r["errors"] for r in results):
        md.append("\n## Errors")
        for r in results:
            for e in r["errors"]:
                md.append(f"- `{r['path']}` — {e}")
    (OUT/"YAML_CORRECTOR_REPORT.md").write_text("\n".join(md) + "\n", encoding="utf-8")
    print(json.dumps(summary, indent=2))

if __name__ == "__main__":
    apply = ("--apply" in sys.argv)
    main(apply=apply)
