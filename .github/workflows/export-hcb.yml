name: export-hcb

on:
  workflow_dispatch:
    inputs:
      repos_csv:
        description: "Comma-separated list of target repos (owner/repo,owner/repo)"
        required: false
        default: "StegVerse/hybrid-collab-bridge"
      export_branch:
        description: "Target branch (created if missing)"
        required: false
        default: "main"
      sync_mode:
        description: "How to sync: mirror (replace) or overlay (merge)"
        required: false
        default: "mirror"
      push_strategy:
        description: "direct (push) or pr (create PR from export/*)"
        required: false
        default: "direct"
      version_tag:
        description: "Version tag to annotate (optional)"
        required: false
        default: "v1.2"
      dry_run:
        description: "If true, do not push — build artifact only"
        required: false
        default: "true"
      tag_repo:
        description: "If true, create/force-push version tag"
        required: false
        default: "true"
      release_create:
        description: "If true, create a GitHub release for version_tag"
        required: false
        default: "true"

permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  export:
    runs-on: ubuntu-latest
    env:
      # Inputs exposed as env for the Python step
      INPUT_REPOS_CSV: ${{ github.event.inputs.repos_csv }}
      INPUT_BRANCH: ${{ github.event.inputs.export_branch }}
      INPUT_SYNC_MODE: ${{ github.event.inputs.sync_mode }}
      INPUT_PUSH_STRATEGY: ${{ github.event.inputs.push_strategy }}
      INPUT_VERSION_TAG: ${{ github.event.inputs.version_tag }}
      INPUT_DRY_RUN: ${{ github.event.inputs.dry_run }}
      INPUT_TAG_REPO: ${{ github.event.inputs.tag_repo }}
      INPUT_RELEASE_CREATE: ${{ github.event.inputs.release_create }}

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build export payload (hybrid-collab-bridge/)
        id: build
        run: |
          set -euo pipefail
          ROOT="$PWD"
          SRC="$ROOT/hybrid-collab-bridge"
          if [ ! -d "$SRC" ]; then
            echo "::error title=Export source missing::Folder hybrid-collab-bridge/ not found at repo root"
            exit 1
          fi

          WORK="/tmp/hcb-export"
          rm -rf "$WORK"
          mkdir -p "$WORK"

          # Copy curated contents
          rsync -a --delete \
            --exclude 'sessions/' \
            --exclude '**/__pycache__/' \
            --exclude '**/.pytest_cache/' \
            --exclude '.applied_*' \
            --exclude '.env*' \
            "$SRC/" "$WORK/"

          # Ensure a VERSION file exists
          if [ ! -f "$WORK/VERSION" ]; then
            echo "${INPUT_VERSION_TAG:-v1.0}" > "$WORK/VERSION"
          fi

          tar -C /tmp -czf /tmp/hcb-export.tar.gz hcb-export
          echo "archive=/tmp/hcb-export.tar.gz" >> $GITHUB_OUTPUT

      - name: Run exporter (push or PR)
        id: export
        env:
          GH_TOKEN: ${{ secrets.STEGVERSE_BOT_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # fallback for some API reads
        run: |
          set -euo pipefail

          # ---- Guards & Inputs ----
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "::error title=Missing token::Secret STEGVERSE_BOT_TOKEN is not set"
            exit 1
          fi

          REPOS_CSV="${INPUT_REPOS_CSV:-}"
          if [ -z "$REPOS_CSV" ]; then
            echo "::error title=Missing input::repos_csv was empty. Provide owner/repo or use default."
            exit 1
          fi

          BRANCH="${INPUT_BRANCH:-main}"
          SYNC_MODE="$(echo "${INPUT_SYNC_MODE:-mirror}" | tr '[:upper:]' '[:lower:]')"
          PUSH_STRATEGY="$(echo "${INPUT_PUSH_STRATEGY:-direct}" | tr '[:upper:]' '[:lower:]')"
          VERSION_TAG="${INPUT_VERSION_TAG:-}"
          DRY_RUN="$(echo "${INPUT_DRY_RUN:-true}" | tr '[:upper:]' '[:lower:]')"
          TAG_REPO="$(echo "${INPUT_TAG_REPO:-true}" | tr '[:upper:]' '[:lower:]')"
          RELEASE_CREATE="$(echo "${INPUT_RELEASE_CREATE:-true}" | tr '[:upper:]' '[:lower:]')"

          echo "Inputs:"
          echo "  repos_csv       : $REPOS_CSV"
          echo "  export_branch   : $BRANCH"
          echo "  sync_mode       : $SYNC_MODE"
          echo "  push_strategy   : $PUSH_STRATEGY"
          echo "  version_tag     : $VERSION_TAG"
          echo "  dry_run         : $DRY_RUN"
          echo "  tag_repo        : $TAG_REPO"
          echo "  release_create  : $RELEASE_CREATE"

          # Prepare export tree
          SRC_DIR="/tmp/hcb-export"
          if [ ! -d "$SRC_DIR" ]; then
            echo "::error title=Build step missing::Export folder not found in /tmp"
            exit 1
          fi

          py() { python - "$@"; }

          py <<'PY'
          import os, sys, json, subprocess, shutil, pathlib, urllib.request, urllib.error

          token = os.environ["GH_TOKEN"]
          headers = {
              "Authorization": f"token {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
          }

          repos_csv     = os.environ.get("INPUT_REPOS_CSV","").strip()
          branch        = os.environ.get("INPUT_BRANCH","main")
          sync_mode     = os.environ.get("INPUT_SYNC_MODE","mirror").lower()
          push_strategy = os.environ.get("INPUT_PUSH_STRATEGY","direct").lower()
          version_tag   = os.environ.get("INPUT_VERSION_TAG","").strip()
          dry_run       = os.environ.get("INPUT_DRY_RUN","true").lower() == "true"
          tag_repo      = os.environ.get("INPUT_TAG_REPO","true").lower() == "true"
          release_create= os.environ.get("INPUT_RELEASE_CREATE","true").lower() == "true"

          src_dir = pathlib.Path("/tmp/hcb-export")
          if not src_dir.is_dir():
              print("::error title=Export payload missing::/tmp/hcb-export is not present")
              sys.exit(1)

          def gh_get(url):
              req = urllib.request.Request(url, headers=headers)
              try:
                  with urllib.request.urlopen(req) as r:
                      return r.getcode(), json.loads(r.read() or b"{}")
              except urllib.error.HTTPError as e:
                  return e.code, json.loads(e.read() or b"{}")
              except Exception as e:
                  return 0, {"error": str(e)}

          def gh_post(url, data):
              req = urllib.request.Request(url, data=json.dumps(data).encode(), headers=headers, method="POST")
              try:
                  with urllib.request.urlopen(req) as r:
                      return r.getcode(), json.loads(r.read() or b"{}")
              except urllib.error.HTTPError as e:
                  return e.code, json.loads(e.read() or b"{}")

          def ensure_repo(owner_repo):
              code, resp = gh_get(f"https://api.github.com/repos/{owner_repo}")
              if code == 200:
                  print(f"✔ Repo exists: {owner_repo}")
                  return True
              if code == 404:
                  owner, repo = owner_repo.split("/", 1)
                  # Try to create under org first, then under user
                  payload = {"name": repo, "private": False, "auto_init": False}
                  code2, resp2 = gh_post(f"https://api.github.com/orgs/{owner}/repos", payload)
                  if code2 == 201:
                      print(f"✔ Created org repo: {owner_repo}")
                      return True
                  # Fallback: user repo
                  code3, resp3 = gh_post("https://api.github.com/user/repos", payload)
                  if code3 == 201:
                      print(f"✔ Created user repo: {owner_repo}")
                      return True
                  print(f"::error title=Create repo failed::{owner_repo} -> {code2 or code3} {resp2 or resp3}")
                  return False
              print(f"::error title=Repo read failed::{owner_repo} -> {code} {resp}")
              return False

          def run(cmd, **kw):
              print("+", " ".join(cmd))
              r = subprocess.run(cmd, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, **kw)
              if r.returncode != 0:
                  print(r.stdout)
                  raise SystemExit(r.returncode)
              return r.stdout

          summary = []
          for repo in [x.strip() for x in repos_csv.split(",") if x.strip()]:
              print(f"\n=== Processing {repo} ===")
              ok = ensure_repo(repo)
              if not ok:
                  summary.append({"repo": repo, "status": "create_failed"})
                  continue

              local = pathlib.Path("/tmp/checkout") / repo.replace("/", "__")
              if local.exists():
                  shutil.rmtree(local)
              run(["git", "clone", f"https://x-access-token:{token}@github.com/{repo}.git", str(local)])

              # Configure author for CI commits
              run(["git", "-C", str(local), "config", "user.name", "StegVerse Bot"])
              run(["git", "-C", str(local), "config", "user.email", "bot@stegverse.org"])

              # Ensure branch exists
              existing_branches = run(["git", "-C", str(local), "branch", "-a"])
              if f"remotes/origin/{branch}" in existing_branches:
                  run(["git", "-C", str(local), "checkout", branch])
              else:
                  run(["git", "-C", str(local), "checkout", "--orphan", branch])
                  # clear working tree if any
                  for p in local.iterdir():
                      if p.name == ".git": continue
                      if p.is_dir(): shutil.rmtree(p)
                      else: p.unlink()
                  run(["git", "-C", str(local), "commit", "--allow-empty", "-m", "chore: init branch"])

              # Sync mode
              if sync_mode == "mirror":
                  # wipe everything but .git
                  for p in local.iterdir():
                      if p.name == ".git": continue
                      if p.is_dir(): shutil.rmtree(p)
                      else: p.unlink()
              # copy export payload over
              for src in src_dir.rglob("*"):
                  rel = src.relative_to(src_dir)
                  dst = local / rel
                  if src.is_dir():
                      dst.mkdir(parents=True, exist_ok=True)
                  else:
                      dst.parent.mkdir(parents=True, exist_ok=True)
                      shutil.copy2(src, dst)

              run(["git", "-C", str(local), "add", "-A"])
              status_changed = subprocess.run(["git", "-C", str(local), "diff", "--cached", "--quiet"]).returncode != 0

              if not status_changed:
                  print("⏭  No changes to commit.")
                  summary.append({"repo": repo, "status": "up-to-date"})
              else:
                  msg = f"export({version_tag or 'snapshot'}): snapshot from {os.environ.get('GITHUB_REPOSITORY','local')}"
                  run(["git", "-C", str(local), "commit", "-m", msg])

                  if dry_run:
                      print("DRY RUN: skipping push.")
                      summary.append({"repo": repo, "status": "dry-run committed"})
                  else:
                      if push_strategy == "pr":
                          pr_branch = f"export/{(version_tag or 'snapshot').replace('/', '-')}"
                          run(["git", "-C", str(local), "checkout", "-B", pr_branch])
                          run(["git", "-C", str(local), "push", "-u", "origin", pr_branch, "--force-with-lease"])
                          # open PR
                          title = f"export: {version_tag or 'snapshot'}"
                          body  = "Automated export from StegVerse-SCW hybrid-collab-bridge module."
                          code, resp = gh_post(f"https://api.github.com/repos/{repo}/pulls",
                                               {"title": title, "head": pr_branch, "base": branch, "body": body})
                          if code in (200, 201):
                              print(f"✔ PR opened: {resp.get('html_url')}")
                              summary.append({"repo": repo, "status": "pr_opened", "url": resp.get("html_url")})
                          else:
                              print(f"::warning title=PR open failed::{repo} -> {code} {resp}")
                              summary.append({"repo": repo, "status": "push_pr_failed"})
                      else:
                          run(["git", "-C", str(local), "checkout", branch])
                          run(["git", "-C", str(local), "push", "-u", "origin", branch])

                      # tag/release
                      if version_tag and not dry_run:
                          if os.environ.get("INPUT_TAG_REPO","true").lower()=="true":
                              # create/force-update lightweight tag
                              run(["git", "-C", str(local), "tag", "-f", version_tag])
                              run(["git", "-C", str(local), "push", "-f", "origin", f"refs/tags/{version_tag}"])
                          if os.environ.get("INPUT_RELEASE_CREATE","true").lower()=="true":
                              code, existing = gh_get(f"https://api.github.com/repos/{repo}/releases/tags/{version_tag}")
                              if code == 200:
                                  print(f"ℹ Release already exists: {existing.get('html_url')}")
                              else:
                                  code, resp = gh_post(f"https://api.github.com/repos/{repo}/releases",
                                                       {"tag_name": version_tag,
                                                        "name": version_tag,
                                                        "body": "Automated export release",
                                                        "prerelease": False,
                                                        "draft": False})
                                  if code in (200,201):
                                      print(f"✔ Release created: {resp.get('html_url')}")
                                  else:
                                      print(f"::warning title=Release failed::{repo} -> {code} {resp}")

          # Write a short summary for the Actions UI
          print("\n--- SUMMARY ---")
          PY

          {
            echo "### Export completed"
            echo ""
            echo "- **Repos:** ${REPOS_CSV}"
            echo "- **Branch:** ${BRANCH}"
            echo "- **Mode:** ${SYNC_MODE}"
            echo "- **Push:** ${PUSH_STRATEGY}"
            echo "- **Dry run:** ${DRY_RUN}"
            echo "- **Tag:** ${VERSION_TAG:-<none>} (tag_repo=${TAG_REPO})"
            echo "- **Release:** ${RELEASE_CREATE}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Upload export artifact
        uses: actions/upload-artifact@v4
        with:
          name: hcb-export-${{ github.run_id }}
          path: /tmp/hcb-export.tar.gz
          if-no-files-found: warn
