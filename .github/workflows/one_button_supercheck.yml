name: One-Button Supercheck (Preflight + Diag + Audit + Auto-Triage) [Unified]

on:
  workflow_dispatch:
    inputs:
      api_base:
        description: "API base URL (blank = skip diagnostics)"
        required: false
        default: ""
      queue_key:
        description: "Worker queue key"
        required: false
        default: "queue:runs"
      timeout_sec:
        description: "Max seconds to wait for worker"
        required: false
        default: "75"
      poll_sec:
        description: "Poll interval seconds"
        required: false
        default: "3"
      auto_apply:
        description: "Apply safe repo triage (scaffold/move ATTIC/remove forbidden)"
        required: false
        default: "false"
      auto_commit:
        description: "Commit changes directly to main (else: open PR)"
        required: false
        default: "false"
      preflight_apply:
        description: "Preflight: apply workflow YAML fixes"
        required: false
        default: "true"
      preflight_autocommit:
        description: "Preflight: auto-commit normalized workflows to main"
        required: false
        default: "true"
  # OPTIONAL push trigger so you can run by touching a file (delete if you don't want it)
  push:
    paths:
      - ".github/trigger/supercheck/**"

permissions:
  contents: write
  pull-requests: write

# Avoid overlapping runs on the same ref
concurrency:
  group: supercheck-${{ github.ref }}
  cancel-in-progress: true

jobs:
  supercheck:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure tools
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y jq curl
          python3 -V

      - name: Read trigger flags (autorun controls)
        id: flags
        run: |
          set -e
          TRG=".github/trigger/supercheck"
          mkdir -p "$TRG"

          has() { [ -f "$TRG/$1" ]; }
          get() { [ -f "$TRG/$1" ] && cat "$TRG/$1" | tr -d '\r' | sed 's/[[:space:]]*$//' || echo ""; }

          # File flags (presence-based)
          F_APPLY=$(has apply.txt && echo true || echo false)
          F_COMMIT=$(has commit.txt && echo true || echo false)
          F_NO_AUTOFIX=$(has no-autofix.txt && echo true || echo false)
          F_PREFLIGHT_ONLY=$(has preflight-only.txt && echo true || echo false)
          F_TRIAGE_ONLY=$(has triage-only.txt && echo true || echo false)
          F_SKIP_DIAG=$(has skip-diag.txt && echo true || echo false)
          F_FAST=$(has fast.txt && echo true || echo false)
          F_DEEP=$(has deep.txt && echo true || echo false)
          F_ATTIC_OFF=$(has attic-off.txt && echo true || echo false)

          # File values (content-based)
          F_API_BASE=$(get diag-url.txt)         # override API base URL
          F_QUEUE_KEY=$(get queue.txt)           # override queue key
          F_TIMEOUT=$(get timeout.txt)           # number (seconds)
          F_POLL=$(get poll.txt)                 # number (seconds)

          # Inputs (strings "true"/"false")
          IN_AUTO_APPLY="${{ github.event.inputs.auto_apply || 'false' }}"
          IN_AUTO_COMMIT="${{ github.event.inputs.auto_commit || 'false' }}"
          IN_PREF_APPLY="${{ github.event.inputs.preflight_apply || 'true' }}"
          IN_PREF_AUTOCOMMIT="${{ github.event.inputs.preflight_autocommit || 'true' }}"
          IN_API_BASE="${{ github.event.inputs.api_base || '' }}"
          IN_QUEUE="${{ github.event.inputs.queue_key || 'queue:runs' }}"
          IN_TIMEOUT="${{ github.event.inputs.timeout_sec || '75' }}"
          IN_POLL="${{ github.event.inputs.poll_sec || '3' }}"

          # Priority: file flags override UI inputs where sensible
          eff_true() { [ "$1" = "true" ] || [ "$2" = "true" ] && echo true || echo false; }
          eff_false_if() { [ "$1" = "true" ] && echo false || echo "$2"; }

          E_AUTO_APPLY=$(eff_true "$F_APPLY" "$IN_AUTO_APPLY")
          E_AUTO_COMMIT=$(eff_true "$F_COMMIT" "$IN_AUTO_COMMIT")

          # Preflight: if no-autofix.txt present => disable applying fixes
          if [ "$F_NO_AUTOFIX" = "true" ]; then
            E_PREF_APPLY=false
          else
            E_PREF_APPLY="$IN_PREF_APPLY"
          fi
          E_PREF_AUTOCOMMIT="$IN_PREF_AUTOCOMMIT"

          # Diagnostics skip
          E_SKIP_DIAG=$(eff_true "$F_SKIP_DIAG" false)

          # API/Queue overrides (file content wins if non-empty)
          if [ -n "$F_API_BASE" ]; then E_API_BASE="$F_API_BASE"; else E_API_BASE="$IN_API_BASE"; fi
          if [ -n "$F_QUEUE_KEY" ]; then E_QUEUE="$F_QUEUE_KEY"; else E_QUEUE="$IN_QUEUE"; fi

          # Timings
          if [ -n "$F_TIMEOUT" ]; then E_TIMEOUT="$F_TIMEOUT"; else E_TIMEOUT="$IN_TIMEOUT"; fi
          if [ -n "$F_POLL" ]; then E_POLL="$F_POLL"; else E_POLL="$IN_POLL"; fi
          # FAST/DEEP presets
          if [ "$F_FAST" = "true" ]; then E_TIMEOUT=30; E_POLL=2; fi
          if [ "$F_DEEP" = "true" ]; then E_TIMEOUT=180; E_POLL=4; fi

          # Triage controls
          E_ATTIC_OFF="$F_ATTIC_OFF"
          E_PREFLIGHT_ONLY="$F_PREFLIGHT_ONLY"
          E_TRIAGE_ONLY="$F_TRIAGE_ONLY"

          # Surface values as outputs
          {
            echo "auto_apply=$E_AUTO_APPLY"
            echo "auto_commit=$E_AUTO_COMMIT"
            echo "preflight_apply=$E_PREF_APPLY"
            echo "preflight_autocommit=$E_PREF_AUTOCOMMIT"
            echo "skip_diag=$E_SKIP_DIAG"
            echo "api_base=$E_API_BASE"
            echo "queue_key=$E_QUEUE"
            echo "timeout_sec=$E_TIMEOUT"
            echo "poll_sec=$E_POLL"
            echo "attic_off=$E_ATTIC_OFF"
            echo "preflight_only=$E_PREFLIGHT_ONLY"
            echo "triage_only=$E_TRIAGE_ONLY"
          } >> "$GITHUB_OUTPUT"

      # ---------- Seed fallbacks so runs never fail early ----------
      - name: Seed fallback helper scripts
        run: |
          set -e
          mkdir -p scripts self_healing_out .github/workflows ATTIC docs
          # validate_and_fix.py (fallback)
          if [ ! -f scripts/validate_and_fix.py ]; then
            cat > scripts/validate_and_fix.py <<'PY'
#\!/usr/bin/env python3
import os, json, sys
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
WF=ROOT/".github"/"workflows"
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
files=sorted([p.as_posix() for p in WF.glob("*.y*ml")]) if WF.exists() else []
summary={"files":len(files),"changed":0,"invalid_before":0,"invalid_after":0,"applied":"--apply" in sys.argv,"note":"fallback validator (real script not found)"}
(OUT/"WORKFLOW_FIX_REPORT.json").write_text(json.dumps({"summary":summary,"results":[{"path":f,"changed":False,"before_valid":True,"after_valid":True,"text_stats":{},"yaml_stats":{}} for f in files]},indent=2),encoding="utf-8")
(OUT/"WORKFLOW_FIX_REPORT.md").write_text("# Workflow Fix Report\n\n- Fallback stub executed (real validator missing)\n- Files found: **{}**\n".format(len(files)),encoding="utf-8")
print(json.dumps(summary, indent=2))
PY
            chmod +x scripts/validate_and_fix.py
          fi
          # repo_audit.py (fallback)
          if [ ! -f scripts/repo_audit.py ]; then
            cat > scripts/repo_audit.py <<'PY'
#\!/usr/bin/env python3
import os, json
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
(OUT/"REPO_INVENTORY.json").write_text(json.dumps({"repo":ROOT.name,"inventory":[],"counts":{"files":0}},indent=2),encoding="utf-8")
(OUT/"REPO_DIFF.json").write_text(json.dumps({"summary":{"required_missing":0,"dir_missing":0,"recommended_missing":0,"forbidden_hits":0,"extras":0},"required_missing":[],"dir_missing":[],"recommended_missing":[],"forbidden_hits":[],"extras":[]},indent=2),encoding="utf-8")
(OUT/"REPO_INVENTORY.md").write_text("# Repo Inventory & Diff\n\n- (fallback stub)\n",encoding="utf-8")
print("OK repo_audit (fallback)")
PY
            chmod +x scripts/repo_audit.py
          fi
          # topic_drift_audit.py (fallback)
          if [ ! -f scripts/topic_drift_audit.py ]; then
            cat > scripts/topic_drift_audit.py <<'PY'
#\!/usr/bin/env python3
import json, time
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
rep={"generated_at":int(time.time()),"files_scanned":0,"idea_tags":{},"attic_files":[],"possibly_unused":[],"commit_topics_last200":[],"drift_ratio_no_topic":None}
(OUT/"DRIFT_REPORT.json").write_text(json.dumps(rep,indent=2),encoding="utf-8")
(OUT/"DRIFT_REPORT.md").write_text("# Drift Report\n\n- (fallback stub)\n",encoding="utf-8")
print("OK drift_report (fallback)")
PY
            chmod +x scripts/topic_drift_audit.py
          fi
          # collect_self_healing.py (fallback)
          if [ ! -f scripts/collect_self_healing.py ]; then
            cat > scripts/collect_self_healing.py <<'PY'
#\!/usr/bin/env python3
import os, json, datetime
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
manifest={"repo":os.getenv("GITHUB_REPOSITORY",ROOT.name),"branch":os.getenv("GITHUB_REF_NAME",""),"generated_at":datetime.datetime.utcnow().isoformat()+"Z","measures":{}}
(OUT/"SELF_HEALING_MANIFEST.json").write_text(json.dumps(manifest,indent=2),encoding="utf-8")
(OUT/"SELF_HEALING_MANIFEST.md").write_text("# Minimal Manifest (fallback)\n",encoding="utf-8")
(OUT/"GAPS.json").write_text(json.dumps({"note":"fallback scan"},indent=2),encoding="utf-8")
(OUT/"REMEDIATIONS.md").write_text("",encoding="utf-8")
print("OK scan (fallback)")
PY
            chmod +x scripts/collect_self_healing.py
          fi
          # auto_triage.py (fallback)
          if [ ! -f scripts/auto_triage.py ]; then
            cat > scripts/auto_triage.py <<'PY'
#\!/usr/bin/env python3
from pathlib import Path
ROOT=Path(__file__).resolve().parents[1]
OUT=ROOT/"self_healing_out"; OUT.mkdir(parents=True, exist_ok=True)
(OUT/"AUTO_TRIAGE_PLAN.json").write_text('{"remove_forbidden":[],"move_to_attic":[],"scaffold_dirs":[],"scaffold_files":[],"keep":[]}',encoding="utf-8")
(OUT/"AUTO_TRIAGE_REPORT.md").write_text("# Auto-Triage Plan\n\n- (fallback stub)\n",encoding="utf-8")
print("OK auto_triage (fallback)")
PY
            chmod +x scripts/auto_triage.py
          fi

      # ---------- PRE-FLIGHT: validate & fix workflow YAML ----------
      - name: Preflight — Validate & Fix Workflows
        env:
          PREFLIGHT_APPLY: ${{ github.event.inputs.preflight_apply }}
        run: |
          set -e
          if [ "${PREFLIGHT_APPLY}" = "true" ]; then
            python3 scripts/validate_and_fix.py --apply || true
          else
            python3 scripts/validate_and_fix.py || true
          fi

      - name: Preflight — Auto-commit normalized workflows
        if: ${{ github.event.inputs.preflight_autocommit == 'true' && github.event.inputs.preflight_apply == 'true' }}
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          git config user.name "workflow-fix-bot"
          git config user.email "bot@stegverse.local"
          git add .github/workflows/*.yml .github/workflows/*.yaml || true
          if git diff --cached --quiet; then
            echo "No workflow changes to commit."
          else
            git commit -m "chore: normalize workflows (auto-fix common YAML issues)"
            git push origin HEAD:main || true
          fi

      # ---------- Optional runtime diagnostics ----------
      - name: Runtime diagnostics (API + Worker)
        id: diag
        env:
          API_BASE: ${{ github.event.inputs.api_base }}
          QUEUE_KEY: ${{ github.event.inputs.queue_key }}
          TIMEOUT_SEC: ${{ github.event.inputs.timeout_sec }}
          POLL_SEC: ${{ github.event.inputs.poll_sec }}
        run: |
          set -euo pipefail
          API="${API_BASE}"
          if [ -z "$API" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            printf '{"ok":null,"skipped":true}\n' > supercheck_diag.json
            exit 0
          fi
          API="$(echo "$API" | sed 's:/*$::')"
          get(){ curl -sS -w "\n%{http_code}" "$1"; }
          post(){ curl -sS -w "\n%{http_code}" -X POST "$1" -H "Content-Type: application/json" -d "{}"; }
          pass=true; report='{"api_base":"'"$API"'","steps":[],"ok":false}'
          add(){ report=$(jq -c --arg n "$1" --argjson ok $2 --argjson data "$3" --arg e "${4:-}" '.steps += [{"name":$n,"ok":$ok,"data":$data,"error":(($e|length>0)?$e:null)}]' <<<"$report"); }
          read -r b s < <(get "$API/v1/ops/health");       if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/health" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/health" false null "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/env/required"); if [ "${s:-500}" = "200" ]; then add "GET /v1/ops/env/required" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/env/required" false null "HTTP $s"; pass=false; fi
          read -r b s < <(get "$API/v1/ops/metrics");      if [ "${s:-500}" = "200" ]; then PB=$(echo "$b"|jq -r '.processed // 0'); add "GET /v1/ops/metrics (before)" true "$(echo "$b"|jq -S .)" ""; else add "GET /v1/ops/metrics (before)" false null "HTTP $s"; pass=false; fi
          read -r b s < <(post "$API/v1/ops/queue/test");  if [ "${s:-500}" = "200" ] && [ "$(echo "$b"|jq -r '.queued // false')" = "true" ]; then add "POST /v1/ops/queue/test" true "$(echo "$b"|jq -S .)" ""; else add "POST /v1/ops/queue/test" false null "HTTP $s"; pass=false; fi
          end=$(( $(date +%s) + ${TIMEOUT_SEC} )); snaps="[]"; PA="$PB"
          if [ "$pass" = true ]; then
            while [ $(date +%s) -lt $end ]; do
              sleep "${POLL_SEC}"; read -r b s < <(get "$API/v1/ops/metrics")
              if [ "${s:-500}" = "200" ]; then snaps=$(jq -c --argjson s "$(echo "$b"|jq -S .)" '.+=[ $s ]' <<<"$snaps"); val=$(echo "$b"|jq -r '.processed // 0'); PA=$val; [ "$PA" -gt "$PB" ] && break; fi
            done
            ok=$([ "$PA" -gt "$PB" ] && echo true || echo false)
            add "Poll metrics until processed increases" "$ok" "$snaps" "before=$PB after=$PA timeout=${TIMEOUT_SEC}s"
            [ "$ok" = true ] || pass=false
          fi
          report=$(jq -c --argjson ok $([ "$pass" = true ] && echo true || echo false) '.ok=$ok' <<<"$report")
          echo "$report" | jq -S . > supercheck_diag.json
          echo "skip=false" >> $GITHUB_OUTPUT
          echo "ok=$pass" >> $GITHUB_OUTPUT

      # ---------- Repo audit + drift + manifest ----------
      - name: Repo Inventory & Diff
        run: python3 scripts/repo_audit.py

      - name: Topic Drift Auditor
        run: python3 scripts/topic_drift_audit.py

      - name: Self-Healing Scan
        run: python3 scripts/collect_self_healing.py

      # ---------- Auto-triage (optional apply) ----------
      - name: Auto-Triage (plan + optional apply)
        env:
          APPLY: ${{ github.event.inputs.auto_apply }}
        run: |
          set -e
          if [ "${APPLY}" = "true" ]; then
            APPLY=1 python3 scripts/auto_triage.py
          else
            python3 scripts/auto_triage.py
          fi

      - name: Commit or PR triage changes
        if: ${{ github.event.inputs.auto_apply == 'true' }}
        env:
          DO_COMMIT: ${{ github.event.inputs.auto_commit }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          git config user.name "supercheck-bot"
          git config user.email "bot@stegverse.local"
          if [ "$DO_COMMIT" = "true" ]; then
            git add -A
            git commit -m "supercheck(auto): apply safe triage" || echo "No changes"
            git push origin HEAD:main || true
          else
            BR="supercheck/triage-${GITHUB_RUN_ID}"
            git checkout -b "$BR" || git checkout "$BR"
            git add -A
            git commit -m "supercheck(auto): apply safe triage" || echo "No changes"
            git push origin "$BR" || true
            TITLE="Supercheck: safe triage (auto)"
            BODY="PR created automatically by One-Button Supercheck."
            curl -sS -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -nc --arg t "$TITLE" --arg b "$BODY" --arg head "$BR" '{"title":$t,"body":$b,"head":$head,"base":"main"}')" \
              "${GITHUB_API_URL}/repos/${GITHUB_REPOSITORY}/pulls" >/dev/null || true

      # ---------- Always assemble & upload artifact ----------
      - name: Ensure artifact dir & context
        if: always()
        run: |
          set -e
          mkdir -p self_healing_out
          echo "== runner env ==" > self_healing_out/RUN_ENV.txt
          env >> self_healing_out/RUN_ENV.txt
          echo "== git status ==" > self_healing_out/GIT_STATUS.txt
          git status >> self_healing_out/GIT_STATUS.txt 2>&1 || true
          echo "== workflows ==" > self_healing_out/TREE_WORKFLOWS.txt
          ls -la .github/workflows >> self_healing_out/TREE_WORKFLOWS.txt 2>&1 || true
          echo "== scripts ==" > self_healing_out/TREE_SCRIPTS.txt
          ls -la scripts >> self_healing_out/TREE_SCRIPTS.txt 2>&1 || true
          [ -f self_healing_out/WORKFLOW_FIX_REPORT.md ] || echo "# Workflow Fix Report\n\n(missing)" > self_healing_out/WORKFLOW_FIX_REPORT.md
          [ -f self_healing_out/REPO_INVENTORY.md ] || echo "# Repo Inventory\n\n(missing)" > self_healing_out/REPO_INVENTORY.md
          [ -f self_healing_out/DRIFT_REPORT.md ] || echo "# Drift Report\n\n(missing)" > self_healing_out/DRIFT_REPORT.md
          [ -f self_healing_out/SELF_HEALING_MANIFEST.md ] || echo "# Manifest\n\n(missing)" > self_healing_out/SELF_HEALING_MANIFEST.md
          [ -f self_healing_out/AUTO_TRIAGE_REPORT.md ] || echo "# Auto-Triage\n\n(missing)" > self_healing_out/AUTO_TRIAGE_REPORT.md
          [ -f supercheck_diag.json ] || echo '{}' > supercheck_diag.json

      - name: Assemble Supercheck Report
        if: always()
        run: |
          set -e
          {
            echo "# Supercheck Report"
            echo
            echo "## Workflow Preflight"
            echo
            cat self_healing_out/WORKFLOW_FIX_REPORT.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Repo Inventory & Diff"
            echo
            cat self_healing_out/REPO_INVENTORY.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Drift Report"
            echo
            cat self_healing_out/DRIFT_REPORT.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Self-Healing Manifest"
            echo
            cat self_healing_out/SELF_HEALING_MANIFEST.md 2>/dev/null || echo "(missing)"
            echo
            echo "## Auto-Triage Plan"
            echo
            cat self_healing_out/AUTO_TRIAGE_REPORT.md 2>/dev/null || echo "(missing)"
            echo
            echo "## API/Worker Diagnostics (if provided)"
            echo '```json'
            head -c 180000 supercheck_diag.json || true
            echo
            echo '```'
          } > supercheck_report.md

      - name: Upload Supercheck Bundle (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: supercheck_bundle
          path: |
            supercheck_report.md
            supercheck_diag.json
            self_healing_out/**
          if-no-files-found: warn
